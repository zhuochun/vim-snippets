# Shebang
snippet shebang
alias #!
	#!/usr/bin/env node
# Strict
snippet use strict
alias strict
	"use strict";
# Prototype
snippet proto
	${1:class_name}.prototype.${2:method_name} =
	function(${3:first_argument}) {
		${4:// body...}
	};
snippet prototype
	${1:class}.prototype = {
		constructor: ${1}
		${2:defaults} : ${3}
	};
# Function
snippet fun
	function ${1:function_name}(${2:argument}) {
		${3:// body...}
	}
# Anonymous Function
snippet f
	function (${1}) {
		${3}
	}${2:;}
# Immediate function
snippet (f
	(function (${1}) {
		${3}
	}(${2}));
# Object Method
snippet :f
	${1:method_name}: function (${2:attribute}) {
		${4}
	}${3:,}
# if
snippet if
	if (${1:true}) {
		${2}
	}
# if ... else
snippet ife
	if (${1:true}) {
		${2}
	} else {
		${3}
	}
# tertiary conditional
snippet ter
	${1:/* condition */} ? ${2:a} : ${3:b}
# switch
snippet switch
	switch (${1:expression}) {
		case '${3:case}':
			${4}
			break;
		${5}
		default:
			${2}
	}
# case
snippet case
	case '${1:case}':
		${2}
		break;
	${3}
# for (...) {...}
snippet for
	for (${1:i = 0}; ${2}; ${3}) {
		${4}
	}
# for (...) {...}
snippet fori
	for (var ${2:i} = 0, l = ${1:arr}.length; $2 < l; $2 ++) {
		var ${3:v} = $1[$2];${4:}
	}
# for (...) {...} (Improved Native For-Loop)
snippet forr
	for (var ${2:i} = ${1:arr}.length - 1; $2 >= 0; $2 --) {
		var ${3:v} = $1[$2];${4:}
	}
# for (property in object ) { ... }
snippet forin
	for (var ${1:prop} in ${2:Things}) {
		${3:$2[$1]}
	}
# while (...) {...}
snippet wh
	while (${1:/* condition */}) {
		${2}
	}
# try
snippet try
	try {
		${1}
	} catch (${2:e}) {
		${3:/* handle error */}
	}
# do...while
snippet do
	do {
		${2}
	} while (${1:/* condition */});
# setTimeout function
snippet timeout
	setTimeout(function () {${3}}${2}, ${1:10});
# Get Elements
snippet get
	getElementsBy${1:TagName}('${2}')${3}
# Get Element
snippet gett
	getElementBy${1:Id}('${2}')${3}
# console.log (Firebug)
snippet cl
	console.log(${1});
# return
snippet ret
	return ${1:result}
# hasOwnProperty
snippet has
	hasOwnProperty(${1})
# docstring
snippet /**
	/**
	 * ${1:description}
	 *
	 */
snippet @par
	@param {${1:type}} ${2:name} ${3:description}
snippet @ret
	@return {${1:type}} ${2:description}
# JSON.parse
snippet jsonp
	JSON.parse(${1:jstr});
# JSON.stringify
snippet jsons
	JSON.stringify(${1:object});
# self-defining function
snippet sdf
	var ${1:function_name} = function (${2:argument}) {
		${3}

		$1 = function ($2) {
			${4}
		};
	};
# singleton
snippet sing
	function ${1:Singleton} (${2:argument}) {
		// the cached instance
		var instance;

		// rewrite the constructor
		$1 = function $1($2) {
			return instance;
		};

		// carry over the prototype properties
		$1.prototype = this;

		// the instance
		instance = new $1();

		// reset the constructor pointer
		instance.constructor = $1;

		${3}

		return instance;
	}
# Crockford's object function
snippet obj
	function object(o) {
		function F() {}
		F.prototype = o;
		return new F();
	}
# Define multiple properties
snippet props
	var ${1:my_object} = Object.defineProperties(
		${2:new Object()},
		{
			${3:property} : {
				get : function $1_$3_getter() {
					// getter code
				},
				set : function $1_$3_setter(value) {
					// setter code
				},
				value        : ${4:value},
				writeable    : ${5:boolean},
				enumerable   : ${6:boolean},
				configurable : ${7:boolean}
			}
		}
	);
# Define single property
snippet prop
	Object.defineProperty(
		${1:object},
		"${2:property}",
		{
			get : function $1_$2_getter() {
				// getter code
			},
			set : function $1_$2_setter(value) {
				// setter code
			},
			value        : ${3:value},
			writeable    : ${4:boolean},
			enumerable   : ${5:boolean},
			configurable : ${6:boolean}
		}
	);
# regular expression
snippet regex positive lookahead
alias pla
	(?=${1})
snippet regex negative lookahead
alias nla
	(?!${1})
snippet regex positive lookbehind
alias plb
	(?<=${1})
snippet regex negative lookbehind
alias nlb
	(?<!${1})
# backbones
snippet view model
	Backbone.View.extend({
		events: {
		},
		initialize: function() {
			${1}
		},
		render: function() {
			return this;
		}
	});
snippet view collection
	Backbone.View.extend({
		events: {
		},
		initialize: function() {
			${1}
			this.collection.on("add", this.addOne, this);
			this.collection.on("reset", this.addAll, this);
		},
		addOne: function(subject) {
		},
		addAll: function() {
			this.collection.forEach(this.addOne, this);
		},
		render: function() {
			this.addAll();
		}
	});
snippet model
	Backbone.Model.extend({${1}});
snippet collection
	Backbone.Collection.extend({
		model: ${1:Model}
	});
snippet router
	Backbone.Router.extend({
		routes: {
			"": "index",
			"${1:path}": "${2:handler}"
		},
		index: function() {
		},
		${2}: function() {
		},
		initialize: function(${3:options}) {
			${4}
		}
	});
snippet history
	Backbone.history.start({pushState: true});
# gulp
snippet gulp init
alias gi
	var gulp = require('gulp')${1};

	gulp.task('default', function(){
		// place code for your default task here
	});
snippet gulp task
alias gt
	gulp.task('${1:task-name}', function() {
		${2}
	});
snippet gulp src
alias gs
	gulp.src('${1:./**}')
		.pipe(${2})${3:;}
snippet gulp pipe
alias gs
	pipe(${1:plugin}(${2}))${3:;}
snippet gulp dest
alias gd
	gulp.dest('${1:./build}')${2:;}
snippet gulp watch
alias gw
	gulp.watch('${1:glob}', ['${3:task}'${4}]);
snippet gulp copy
alias gcp
	gulp.src('${1:src/**}')
		.pipe(gulp.dest('${2:./build/**}'));
snippet gulp coffee
	gulp.task('coffee', function() {
		gulp.src('./coffee/*.coffee')
			.pipe(coffee(${1}))
			.pipe(gulp.dest('./js'));
	});
snippet gulp less
	gulp.task('less', function() {
		gulp.src('./less/*.less')
			.pipe(less({compress: ${1:true}}))
			.pipe(gulp.dest('./css'));
	});
# BDD
snippet describe
alias des
	describe("${1:context to test}", function() {
		${2}
	});
snippet it
	it("${1:should do something}", function() {
		${2}
	});
snippet it async
alias ita
	it("${1:should do something async}", function(done) {
		${2:done()}
	});
snippet before
	before(function(${1:done}) {
		${2}
	});
snippet after
	after(function(${1:done}) {
		${2}
	});
snippet beforeEach
	beforeEach(function(${1:done}) {
		${2}
	});
snippet afterEach
	afterEach(function(${1:done}) {
		${2}
	});
# Chai - Assert
snippet chai require assert
	var assert = require("chai").assert${1:;}
snippet chai browser assert
	var assert = chai.assert${1:;}
snippet assert
alias as
	assert(${1:expression}, '${2:message}');
snippet assert equal
alias ae
	assert.equal(${1:actual}, ${2:expected}, '${3:message}');
snippet assert not equal
alias ane
	assert.notEqual(${1:actual}, ${2:expected}, '${3:message}');
snippet assert strict equal
alias ase
	assert.strictEqual(${1:actual}, ${2:expected}, '${3:message}');
snippet assert not strict equal
alias anse
	assert.notStrictEqual(${1:actual}, ${2:expected}, '${3:message}');
snippet assert deep equal
alias ade
	assert.deepEqual(${1:actual}, ${2:expected}, '${3:message}');
snippet assert not deep equal
alias ande
	assert.notDeepEqual(${1:actual}, ${2:expected}, '${3:message}');
snippet assert isTrue
alias at
	assert.isTrue(${1:value}, '${2:message}');
snippet assert isFalse
alias af
	assert.isFalse(${1:value}, '${2:message}');
snippet assert isNull
	assert.isNull(${1:value}, '${2:message}');
snippet assert isUndefined
	assert.isUndefined(${1:value}, '${2:message}');
snippet assert isDefined
	assert.isDefined(${1:value}, '${2:message}');
snippet assert isFunction
	assert.isFunction(${1:value}, '${2:message}');
snippet assert isObject
	assert.isObject(${1:value}, '${2:message}');
snippet assert isArray
	assert.isArray(${1:value}, '${2:message}');
snippet assert isString
	assert.isString(${1:value}, '${2:message}');
snippet assert isNumber
	assert.isNumber(${1:value}, '${2:message}');
snippet assert typeOf
	assert.typeOf(${1:value}, ${2:name}, '${3:message}');
snippet assert match
	assert.match(${1:value}, ${2:regex}, '${3:message}');
snippet assert lengthOf
	assert.lengthOf(${1:object}, ${2:length}, '${3:message}');
# Chai - Expect
snippet chai require expect
	var expect = require("chai").expect${1:;}
snippet chai browser expect
	var expect = chai.expect${1:;}
snippet expect general
alias ex
	expect(${1:expression}).to.${2:equal}(${3});
snippet expect equal
alias ee
	expect(${1:expression}).to.equal(${2});
snippet expect not equal
alias ene
	expect(${1:expression}).to.not.equal(${2});
snippet expect deep equal
alias ede
	expect(${1:expression}).to.deep.equal(${2});
snippet expect eql
alias eeql
	expect(${1:expression}).to.eql(${2});
snippet expect be a
	expect(${1:expression}).to.be.a("${2:string}");
snippet expect be instanceof
	expect(${1:expression}).to.be.instanceof("${2:string}");
snippet expect be true
alias ebt
	expect(${1:expression}).to.be.true;
snippet expect be false
alias ebf
	expect(${1:expression}).to.be.false;
snippet expect be null
	expect(${1:expression}).to.be.null;
snippet expect be defined
	expect(${1:expression}).to.be.defined;
snippet expect be undefined
	expect(${1:expression}).to.be.undefined;
snippet expect be empty
	expect(${1:expression}).to.be.empty;
snippet expect be above
	expect(${1:expression}).to.be.above(${2});
snippet expect be below
	expect(${1:expression}).to.be.below(${2});
snippet expect be within
	expect(${1:expression}).to.be.within(${2});
snippet expect exist
	expect(${1:expression}).to.exist;
snippet expect include
	expect(${1:expression}).to.include(${2});
snippet expect contain
	expect(${1:expression}).to.contain(${2});
snippet expect match
alias em
	expect(${1:expression}).to.match(/${2}/);
snippet expect throw
	expect(${1:expression}).to.throw(${2});
snippet expect satisfy
	expect(${1:expression}).to.satisfy(function(${2:args}) {
		${3}
	});
# jasmine
snippet jexpect toBe
	expect(${1:expression}).toBe(${2:true});
snippet jexpect toNotBe
	expect(${1:expression}).toNotBe(${2:true});
snippet jexpect toEqual
	expect(${1:expression}).toEqual(${2:value});
snippet jexpect toNotEqual
	expect(${1:expression}).toNotEqual(${2:value});
snippet jexpect toMatch
	expect(${1:expression}).toMatch(${2:regex});
snippet jexpect toNotMatch
	expect(${1:expression}).toNotMatch(${2:regex});
snippet jexpect toBeDefined
	expect(${1:expression}).toBeDefined();
snippet jexpect toBeUndefined
	expect(${1:expression}).toBeUndefined();
snippet jexpect toBeNull
	expect(${1:expression}).toBeNull();
snippet jexpect toBeTruthy
	expect(${1:expression}).toBeTruthy();
snippet jexpect toBeFalsy
	expect(${1:expression}).toBeFalsy();
snippet jexpect toContain
	expect(${1:expression}).toContain(${2:string});
snippet jexpect toNotContain
	expect(${1:expression}).toNotContain(${2:string});
snippet jexpect toBeLessThan
	expect(${1:expression}).toBeLessThan(${2:number});
snippet jexpect toBeGreaterThan
	expect(${1:expression}).toBeGreaterThan(${2:number});
snippet jexpect toBeNaN
	expect(${1:expression}).toBeNaN();
snippet jexpect toBeCloseTo
	expect(${1:expression}).toBeCloseTo(${2:precision});
snippet jexpect toThrow
	expect(${1:expression}).toThrow();
# angular
