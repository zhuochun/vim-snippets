########################################
# Ruby snippets - for Rails, see below #
########################################

# encoding for Ruby 1.9
snippet enc
	# encoding: utf-8

# #!/usr/bin/env ruby
snippet #!
	#!/usr/bin/env ruby
	# encoding: utf-8

# New Block
snippet =b
	=begin rdoc
		${1}
	=end
snippet prot
	protected

	${1}
snippet priv
	private

	${1}
snippet y
	:yields: ${1:arguments}
snippet rb
	#!/usr/bin/env ruby -wKU
snippet beg
	begin
		${3}
	rescue ${1:Exception} => ${2:e}
	end

snippet req require
	require "${1}"${2}
snippet reqr
	require_relative "${1}"${2}
snippet #
	# =>
snippet end
	__END__
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet deft
	def test_${1:case_name}
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet eif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet wh
	while ${1:condition}
		${2}
	end
snippet for
	for ${1:e} in ${2:c}
		${3}
	end
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		def initialize(${2:args})
			${3}
		end
	end
snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end
	end
snippet cla ClassName = Struct .. do .. end
	${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end
	end
snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
	end
snippet cla class << self .. end
	class << ${1:self}
		${2}
	end
snippet cla class .. < DelegateClass .. initialize .. end
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end
	end
snippet cla class model without db
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		include ActiveModel::Validations
		include ActiveModel::Conversion

		attr_accessor :${1:attributes}

		def initialize(attributes = {})
			attributes.each do |name, value|
				send("#{name}=", value)
			end
		end

		def persisted?
			false
		end
	end
snippet struct
	Struct.new(:${1:attr_name})
snippet mod module .. end
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
	end
snippet mod module .. module_function .. end
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		module_function

		${2}
	end
snippet mod module .. ClassMethods .. end
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
# attr_reader
snippet atr
	attr_reader :${1:attr_names}
# attr_writer
snippet atw
	attr_writer :${1:attr_names}
# attr_accessor
snippet atrw
	attr_accessor :${1:attr_names}
snippet atp
	attr_protected :${1:attr_names}
snippet ata
	attr_accessible :${1:attr_names}
snippet ana
	accepts_nested_attributes_for :${1:association}
# ivc == instance variable cache
snippet ivc
	@${1:variable_name} ||= ${2:chached_value}
# include
snippet inc
	include ${1:ActiveModel::}${2:Validations}
snippet ext
	extend ${1:ActiveSupport::}${2:Memoizable}
# include Enumerable
snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
# def initialize
snippet init
	def initialize(${1:args})
		${2}
	end
# def initialize
snippet definit
	def initialize(${1:args})
		${2}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet am
	alias_method :${1:new_name}, :${2:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet file File.foreach() { |line| .. }
	File.foreach(${1:"path/to/file"}) { |${2:line}| ${3} }
snippet file File.read()
	File.read(${1:"path/to/file"})${2}
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }
snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${2} }
snippet fil
	fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
snippet flao
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
	zip(${1:enums}) { |${2:row}| ${3} }
# downto(0) { |n| .. }
snippet dow
	downto(${1:0}) { |${2:n}| ${3} }
snippet ste
	step(${1:2}) { |${2:n}| ${3} }
snippet tim
	times { |${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet loo
	loop { ${1} }
snippet ea
	each { |${1:e}| ${2} }
snippet ead
	each do |${1:e}|
		${2}
	end
snippet eab
	each_byte { |${1:byte}| ${2} }
snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${2} }
snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet eai
	each_index { |${1:i}| ${2} }
snippet eaid
	each_index do |${1:i}|
		${2}
	end
snippet eak
	each_key { |${1:key}| ${2} }
snippet eakd
	each_key do |${1:key}|
		${2}
	end
snippet eal
	each_line { |${1:line}| ${2} }
snippet eald
	each_line do |${1:line}|
		${2}
	end
snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet eapd
	each_pair do |${1:name}, ${2:val}|
		${3}
	end
snippet eas-
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet easd-
	each_slice(${1:2}) do |${2:group}|
		${3}
	end
snippet eav
	each_value { |${1:val}| ${2} }
snippet eavd
	each_value do |${1:val}|
		${2}
	end
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet eawid
	each_with_index do |${1:e}, ${2:i}|
		${3}
	end
snippet eawo
	each_with_object(${1:init}) { |${2:e}, ${3:var}| ${4} }
snippet eawod
	each_with_object(${1:init}) do |${2:e}, ${3:var}|
		${4}
	end
snippet reve
	reverse_each { |${1:e}| ${2} }
snippet reved
	reverse_each do |${1:e}|
		${2}
	end
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet injd
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end
snippet red
	reduce(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet redd
	reduce(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end
snippet map method
	map(&:${1:id})
snippet map block
	map { |${1:e}| ${2} }
snippet map do block
	map do |${1:e}|
		${2}
	end
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sor
	sort { |a, b| ${1} }
snippet sorb
	sort_by { |${1:e}| ${2} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet cl
	classify { |${1:e}| ${2} }
snippet col
	collect { |${1:e}| ${2} }
snippet cold
	collect do |${1:e}|
		${2}
	end
snippet det
	detect { |${1:e}| ${2} }
snippet detd
	detect do |${1:e}|
		${2}
	end
snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }
snippet fin
	find { |${1:e}| ${2} }
snippet findo
	find do |${1:e}|
		${2}
	end
snippet fina
	find_all { |${1:e}| ${2} }
snippet finad
	find_all do |${1:e}|
		${2}
	end
snippet fino
	find_or_initialize_by_name(${1:attributes}) do |${1:e}|
		${2}
	end
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet scad
	scan(${1:/pattern/}) do |${2:match}|
		${3}
	end
snippet max
	max { |a, b| ${1} }
snippet min
	min { |a, b| ${1} }
snippet par
	partition { |${1:e}| ${2} }
snippet pard
	partition do |${1:e}|
		${2}
	end
snippet rej
	reject { |${1:e}| ${2} }
snippet rejd
	reject do |${1:e}|
		${2}
	end
snippet sel
	select { |${1:e}| ${2} }
snippet seld
	select do |${1:e}|
		${2}
	end
snippet lam
	lambda { |${1:args}| ${2} }
snippet do empty
	do
		${1}
	end
snippet do default
	do |${1:v}|
		${2}
	end
snippet :
	${1:key}: ${2:"value"}
snippet ope
	open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# path_from_here()
snippet fpath
	File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${3}
	end
# option_parse {}
snippet optp
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
snippet opt
	opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
	         "${4:Option description.}") do |${5:opt}|
		${6}
	end
snippet tc
	require "test/unit"

	require "${1:library_file_name}"

	class Test${2:$1} < Test::Unit::TestCase
		def test_${3:case_name}
			${4}
		end
	end
snippet ts
	require "test/unit"

	require "tc_${1:test_case_file}"
	require "tc_${2:test_case_file}"${3}
snippet as assert
	assert ${1:test}, "${2:Failure message.}"${3}
snippet ase assert_equal
	assert_equal ${1:expected}, ${2:actual}${3}
snippet asne assert_not_equal
	assert_not_equal ${1:unexpected}, ${2:actual}${3}
snippet asid assert_in_delta
	assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2 ** -20}${4}
snippet asio assert_instance_of
	assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}${3}
snippet asko assert_kind_of
	assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}${3}
snippet asn assert_nil
	assert_nil ${1:instance}${2}
snippet asnn assert_not_nil
	assert_not_nil ${1:instance}${2}
snippet asm assert_match
	assert_match /${1:expected_pattern}/, ${2:actual_string}${3}
snippet asnm assert_no_match
	assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}${3}
snippet aso assert_operator
	assert_operator ${1:left}, :${2:operator}, ${3:right}${4}
snippet asr assert_raise
	assert_raise ${1:Exception} { ${2} }
snippet asrd assert_raise
	assert_raise ${1:Exception} do
		${2}
	end
snippet asnr assert_nothing_raised
	assert_nothing_raised ${1:Exception} { ${2} }
snippet asnrd assert_nothing_raised
	assert_nothing_raised ${1:Exception} do
		${2}
	end
snippet asrt assert_respond_to
	assert_respond_to ${1:object}, :${2:method}${3}
snippet ass assert_same
	assert_same ${1:expected}, ${2:actual}${3}
snippet ass assert_send
	assert_send [${1:object}, :${2:message}, ${3:args}]${4}
snippet asns assert_not_same
	assert_not_same ${1:unexpected}, ${2:actual}${3}
snippet ast assert_throws
	assert_throws :${1:expected} { ${2} }
snippet astd assert_throws
	assert_throws :${1:expected} do
		${2}
	end
snippet asnt assert_nothing_thrown
	assert_nothing_thrown { ${1} }
snippet asntd assert_nothing_thrown
	assert_nothing_thrown do
		${1}
	end
snippet fl flunk
	flunk "${1:Failure message.}"${2}
# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end
snippet rep
	results.report("${1:name}:") { TESTS.times { ${2} }}
# Marshal.dump(.., file)
snippet Md
	File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
snippet Ml
	File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }${3}
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
snippet Pn-
	PStore.new(${1:"file_name.pstore"})${2}
snippet tra
	transaction(${1:true}) { ${2} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:"//Xpath"}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split("::").inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet nam
	namespace :${1:`vim_snippets#Filename()`} do
		${2}
	end
snippet tas
	desc "${1:Task description}"
	task ${2:task_name}: ${3:[:dependent, :tasks]} do
		${4}
	end
# block
snippet b
	{ |${1:var}| ${2} }
snippet begin
	begin
		raise 'A test exception.'
	rescue Exception => e
		puts e.message
		puts e.backtrace.inspect
	else
		# other exception
	ensure
		# always executed
	end
#debugging
snippet debug
	require 'ruby-debug'; debugger; true;
snippet pry
	require 'pry'; binding.pry
#############################################
# Rails snippets - for pure Ruby, see above #
#############################################
snippet art assert_redirected_to action
	assert_redirected_to ${1:action}: "${2:index}"}
snippet art assert_redirected_to path
	assert_redirected_to ${1:parent}_path ${2}
snippet asd assert_difference
	assert_difference "${1:Model}.${2:count}", ${3:1} do
		${4}
	end
snippet asnd assert_no_difference
	assert_no_difference "${1:Model}.${2:count}" do
		${3}
	end
snippet asre assert_response
	assert_response :${1:success}, @response.body${2}
snippet asrj assert_rjs
	assert_rjs :${1:replace}, "${2:dom id}"
snippet ass assert_select
	assert_select '${1:path}', ${2:text}: '${3:inner_html' ${4:do}
snippet bt belongs_to
	belongs_to :${1:association}
snippet btp belongs_to (polymorphic)
	belongs_to :${1:association}, polymorphic: true${2}
snippet crw
	cattr_accessor :${1:attr_names}
snippet defcreate
	def create
		@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])

		respond_to do |format|
			if @$1.save
				flash[:notice] = '$2 was successfully created.'
				format.html { redirect_to(@$1) }
				format.json  { render json: @$1, status: :created, location: @$1 }
			else
				format.html { render :action => "new" }
				format.json  { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end${3}
snippet defdestroy
	def destroy
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
		@$1.destroy

		respond_to do |format|
			format.html { redirect_to($1s_url) }
			format.json  { head :ok }
		end
	end${3}
snippet defedit
	def edit
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	end
snippet defindex
	def index
		@${1:model_class_name} = ${2:ModelClassName}.all

		respond_to do |format|
			format.html # index.html.erb
			format.json  { render json: @$1s }
		end
	end${3}
snippet defnew
	def new
		@${1:model_class_name} = ${2:ModelClassName}.new

		respond_to do |format|
			format.html # new.html.erb
			format.json  { render json: @$1 }
		end
	end${3}
snippet defshow
	def show
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			format.html # show.html.erb
			format.json { render json: @$1 }
		end
	end${3}
snippet defupdate
	def update
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			if @$1.update_attributes(params[:$1])
				flash[:notice] = '$2 was successfully updated.'
				format.html { redirect_to(@$1) }
				format.json { head :ok }
			else
				format.html { render action: "edit" }
				format.json { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end${3}
snippet dele delegate .. to
	delegate :${1:methods}, to: :${2:object}
snippet dele delegate .. to .. prefix .. allow_nil
	delegate :${1:methods}, to: :${2:object}, prefix: :${3:prefix}, allow_nil: ${4:allow_nil}
snippet flash
	flash[:${1:notice}] = "${2}"
snippet hasabtm
	has_and_belongs_to_many :${1:object}, join_table: "${2:table_name}", foreign_key: "${3}_id"${4}
snippet hasm
	has_many :${1:object}
snippet hasmd
	has_many :${1:other}s, class_name: "${2:$1}", foreign_key: "${3:$1}_id", dependent: :destroy${4}
snippet hasmt
	has_many :${1:object}, through: :${2:object}
snippet haso
	has_one :${1:object}
snippet hasod
	has_one :${1:object}, dependent: :${2:destroy}
snippet i18
	I18n.t('${1:type.key}')${2}
snippet ist
	<%= image_submit_tag("${1:agree.png}", :id => "${2:id}"${3} %>
snippet log
	Rails.logger.${1:debug} ${2}
snippet log2
	RAILS_DEFAULT_LOGGER.${1:debug} ${2}
snippet logd
	logger.debug { "${1:message}" }${2}
snippet loge
	logger.error { "${1:message}" }${2}
snippet logf
	logger.fatal { "${1:message}" }${2}
snippet logi
	logger.info { "${1:message}" }${2}
snippet logw
	logger.warn { "${1:message}" }${2}
snippet mapc
	${1:map}.${2:connect} '${3:controller/:action/:id}'
snippet mapca
	${1:map}.catch_all "*${2:anything}", :controller => "${3:default}", :action => "${4:error}"${5}
snippet mapr
	${1:map}.resource :${2:resource}
snippet maprs
	${1:map}.resources :${2:resource}
snippet mapwo
	${1:map}.with_options :${2:controller} => '${3:thing}' do |$3|
		${4}
	end
snippet mbs before_save
	before_save :${1:method}
snippet mcht
	change_table :${1:table_name} do |t|
		${2}
	end
snippet mrw
	mattr_accessor :${1:attr_names}
snippet oa order
	order("${1:field}")
snippet od order
	order("${1:field} DESC")
snippet pa params
	params[:${1:id}]${2}
snippet ra render
	render action: "${1:action}"
snippet ral render action
	render action: "${1:action}", layout: "${2:layoutname}"
snippet rest respond_to
	respond_to do |format|
		format.${1:html} { ${2} }
	end
snippet rf render file
	render file: "${1:filepath}"
snippet rfu render file
	render file: "${1:filepath}", use_full_path: ${2:false}
snippet ri render inline
	render inline: "${1:<%= 'hello' %>}"
snippet ril render inline
	render inline: "${1:<%= 'hello' %>}", locals: { ${2::name}: "${3:value}"${4} }
snippet rit render inline
	render inline: "${1:<%= 'hello' %>}", type: ${2::rxml}
snippet rxml xml
	render xml: ${1:text to render}
snippet rjson json
	render json: ${1:text to render}
snippet rl render layout
	render layout: "${1:layoutname}"
snippet rn render nothing
	render nothing: ${1:true}
snippet rns render nothing
	render nothing: ${1:true}, status: ${2:401}
snippet rp render partial
	render partial: "${1:item}"
snippet rpc render partial
	render partial: "${1:item}", collection: ${2:@$1s}
snippet rpl render partial
	render partial: "${1:item}", locals: { ${2:$1}: ${3:@$1} }
snippet rpo render partial
	render partial: "${1:item}", object: ${2:@$1}
snippet rps render partial
	render partial: "${1:item}", status: ${2:500}
snippet rt render text
	render text: "${1:text to render}"
snippet rtl render text
	render text: "${1:text to render}", layout: "${2:layoutname}"
snippet rtlt render text
	render text: "${1:text to render}", layout: ${2:true}
snippet rts render text
	render text: "${1:text to render}", status: ${2:401}
snippet ru render update
	render :update do |${1:page}|
		$1.${2}
	end
snippet defscope default scope
	default_scope -> { ${1:scope} }
snippet scope ->
	scope :${1:name}, -> { ${2:scope} }
snippet scope lambda
	scope :${1:name}, lambda do |${2:value}|
		${3:scope}
	end
snippet sha1
	Digest::SHA1.hexdigest(${1:string})
snippet sweeper
	class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper
		observe $1

		def after_save(${2:model_class_name})
			expire_cache($2)
		end

		def after_destroy($2)
			expire_cache($2)
		end

		def expire_cache($2)
			expire_page
		end
	end
snippet validator
	class ${1:What}Validator < ActiveRecord::${2:Each}Validator
		def validate_each(record, attribute, value)
			${3}
		end
	end
snippet validate
	validates :${1:method}
snippet validates
	validates :${1:attribute}, ${2:validators}
snippet validates acceptance
	validates :${1:terms}, acceptance: true
snippet validates confirmation
	validates :${1:attribute}, confirmation: true
snippet validates exclusion
	validates :${1:attribute}, exclusion: { in: ${2:%w( mov avi )} }
snippet validates format
	validates :${1:attribute}, format: { with: /${2:regex}/ }
snippet validates inclusion
	validates :${1:attribute}, inclusion: { in: %w(${2: mov avi }) }
snippet validates length
	validates :${1:attribute}, length: { in: ${2:3}..${3:20} }
snippet validates numericality
	validates :${1:attribute}, numericality: ${1:true}
snippet validates presence
	validates :${1:attribute}, presence: true
snippet validates uniqueness
	validates :${1:attribute}, uniqueness: true
snippet validates_associated
	validates_associated :${1:attribute}
snippet format
	format.${1:js|xml|html} { ${2} }
snippet where field:value
	where(${1:field}: ${2:value})
snippet where condition
	where(${1:"conditions"}${2:, bind_var})
snippet xdelete
	xhr :delete, :${1:destroy}, :id => ${2:1}${3}
snippet xget
	xhr :get, :${1:show}, :id => ${2:1}${3}
snippet xpost
	xhr :post, :${1:create}, :${2:object} => { ${3} }
snippet xput
	xhr :put, :${1:update}, :id => ${2:1}, :${3:object} => { ${4} }${5}
# ActiveSupport Test Case
snippet test
	test "${1:shold do something}" do
		${2}
	end
snippet setup
	def setup
		${1}
	end
###########################
#   migrations snippets   #
###########################
snippet mac
	add_column :${1:table_name}, :${2:column_name}, :${3:data_type}
snippet mai
	add_index :${1:table_name}, :${2:column_name}
snippet mrc
	remove_column :${1:table_name}, :${2:column_name}
snippet mrnc
	rename_column :${1:table_name}, :${2:old_column_name}, :${3:new_column_name}
snippet mcc
	change_column :${1:table}, :${2:column}, :${3:type}
snippet mnc
	t.${1:string} :${2:title}${3:, null: false}${4}
snippet mct
	create_table :${1:table_name} do |t|
		${2}
	end
snippet migration class .. < ActiveRecord::Migration .. def up .. def down .. end
	class ${1:class_name} < ActiveRecord::Migration
		def up
			${2}
		end

		def down
		end
	end
snippet migration class .. < ActiveRecord::Migration .. def change .. end
	class ${1:class_name} < ActiveRecord::Migration
		def change
			${2}
		end
	end
snippet trc
	t.remove :${1:column}
snippet tre
	t.rename :${1:old_column_name}, :${2:new_column_name}
	${3}
snippet tref
	t.references :${1:model}
snippet tcb
	t.boolean :${1:title}
	${2}
snippet tcbi
	t.binary :${1:title}, :limit => ${2:2}.megabytes
	${3}
snippet tcd
	t.decimal :${1:title}, :precision => ${2:10}, :scale => ${3:2}
	${4}
snippet tcda
	t.date :${1:title}
	${2}
snippet tcdt
	t.datetime :${1:title}
	${2}
snippet tcf
	t.float :${1:title}
	${2}
snippet tch
	t.change :${1:name}, :${2:string}, :${3:limit} => ${4:80}
	${5}
snippet tci
	t.integer :${1:title}
	${2}
snippet tcl
	t.integer :lock_version, :null => false, :default => 0
	${1}
snippet tcr
	t.references :${1:taggable}, :polymorphic => { :default => '${2:Photo}' }
	${3}
snippet tcs
	t.string :${1:title}
	${2}
snippet tct
	t.text :${1:title}
	${2}
snippet tcti
	t.time :${1:title}
	${2}
snippet tcts
	t.timestamp :${1:title}
	${2}
snippet tctss
	t.timestamps
	${1}
##########################
#     Rspec snippets     #
##########################
snippet desc class
	describe ${1:class_name} do
		${2}
	end
snippet desc method
	describe "${1:#method}" do
		${2:pending "Not implemented"}
	end
snippet context
	context "${1:message}" do
		${2}
	end
snippet bef rspec each/all
	before :${1:each} do
		${2}
	end
snippet aft rspec each/all
	after :${1:each} do
		${2}
	end
snippet let
	let(:${1:object}) ${2}
snippet let!
	let!(:${1:object}) ${2}
snippet subj object
	subject(:${1:instance}) { ${2} }
snippet subj default
	subject { ${1} }
snippet subj .
	subject.${1:method}
snippet spec
	specify { subject.${1} }
snippet expect to
	expect { ${1:object} }.to ${2}
snippet expect change
	expect { ${1:object} }.to change { ${2} }.${3:by(1)}
snippet from .. to ..
	from(${1:0}).to(${2:2})
snippet expect raise_error
	expect { ${1:object} }.to raise_error ${2:StandardError}, /${3:message_regex}/
snippet have
	${1:instance}.should have(${2:1}).${3:items}
snippet shared
	shared_examples_for ${1:"shared examples name"} do
		${2}
	end
snippet ibl
	it_behaves_like ${1:"shared examples name"} do
		${2}
	end
snippet it
	it "${1:spec_name}" do
		${2}
	end
snippet its
	its(:${1:method}) { should ${2} }
snippet should_receive
	should_receive(:${1:method}).with(${2:attrs}).and_return(${3:returns})
snippet stub
	stub(:${1:method}).returns(${3:returns})
snippet is
	it { should ${1} }
snippet isn
	it { should_not ${1} }
#ShouldaMatchers#ActionController
snippet isfp
	it { should filter_param :${1:key} }
snippet isrt
	it { should redirect_to ${1:url} }
snippet isrtp
	it { should render_template ${1} }
snippet isrwl
	it { should render_with_layout ${1} }
snippet isrf
	it { should rescue_from ${1:exception} }
snippet isrw
	it { should respond_with ${1:status} }
snippet isr
	it { should route(:${1:method}, '${2:path}') }
snippet isss
	it { should set_session :${1:key} }
snippet issf
	it { should set_the_flash('${1}') }
#ShouldaMatchers#ActiveModel
snippet isama
	it { should allow_mass_assignment_of :${1} }
snippet isav
	it { should allow_value(${1}).for :${2} }
snippet isee
	it { should ensure_exclusion_of :${1} }
snippet isei
	it { should ensure_inclusion_of :${1} }
snippet isel
	it { should ensure_length_of(:${1}).is_at_least(${2}).is_at_most(${3}) }
snippet isva
	it { should validate_acceptance_of :${1} }
snippet isvc
	it { should validate_confirmation_of :${1} }
snippet isvn
	it { should validate_numericality_of :${1} }
snippet isvp
	it { should validate_presence_of :${1} }
snippet isvu
	it { should validate_uniqueness_of :${1} }
#ShouldaMatchers#ActiveRecord
snippet isana
	it { should accept_nested_attributes_for :${1} }
snippet isbt
	it { should belong_to :${1} }
snippet isbtcc
	it { should belong_to(:${1}).counter_cache ${2:true} }
snippet ishbtm
	it { should have_and_belong_to_many :${1} }
snippet isbv
	it { should be_valid }${1}
snippet ishc
	it { should have_db_column :${1} }
snippet ishi
	it { should have_db_index :${1} }
snippet ishm
	it { should have_many :${1} }
snippet ishmt
	it { should have_many(:${1}).through :${2} }
snippet isho
	it { should have_one :${1} }
snippet ishro
	it { should have_readonly_attribute :${1} }
snippet iss
	it { should serialize :${1} }
snippet isres
	it { should respond_to :${1} }
snippet isresw
	it { should respond_to(:${1}).with(${2}).arguments }
snippet super_call
	${1:super_class}.instance_method(:${2:method}).bind(self).call
# TomDoc
snippet doc method
	# ${1:Public/Internal/Deprecated}: ${2:what does it do?}
	#
	# ${3:args - Description}
	#
	# Examples
	#
	# ${4:bar()}
	#
	# ${5:Returns nothing.}
snippet doc class/module
	# ${1:Public/Internal/Deprecated}: ${2:what does it do?}
	#
	# Examples
	#
	# ${3:bar()}
snippet doc constant
	# ${1:Public/Internal/Deprecated}: [${2:Type}] ${3:its purpose}
snippet doca argument
	${1:arg} - ${2:description}
snippet doca argument with default
	${1:arg} - ${2:description}(default: ${3})
snippet docr returns
	Returns ${1}
# Regex
# avoid using $1-9 as it can be hard to track
snippet rgn named group
	(?<${1:name}${2:regex})
# x modifier
snippet rgx
	%r{
		${1}
	}x${2}
# to_json
snippet to_json only
	${1:instance}.to_json(include: ${2}, only: ${3})${4}
snippet to_json except
	${1:instance}.to_json(include: ${2}, except: ${3})${4}
# capybara cheatsheet
snippet hasc
	has_content?(${1:text})
snippet click link
	click_link ${1:id/text}
snippet click button
	click_button ${1:id/text}
snippet click on link/button
	click_on ${1:id/text}
snippet fill fill in
	fill_in '${1:field}', with: ${2:value}
snippet choose radio button
	choose '${1:a radio button}'
snippet check checkbox
	check '${1:a checkbox}'
snippet uncheck checkbox
	uncheck '${1:a checkbox}'
snippet attach attach file
	attach_file '${1:field}', '${2:path_to_file}'
snippet select select dropdown
	select '${1:option}', from: '${2:field}'
snippet find default
	find("${1:id}").${2:action}
snippet find all
	all("${1:id}").${2:action}
snippet find field
	find_field('${1:text}').${2:action}
snippet find link
	find_link('${1:text}').${2:action}
snippet find button
	find_button('${1:text}').${2:action}
snippet within
	within('${1:selector}') do
		${2:tests}
	end
# FactoryGirl
snippet fgd
	FactoryGirl.define do
		factory :${1:name} do
			${2:attr} ${3:value}
		end
	end
snippet factory
	factory :${1:name}${2:, class: Model} do
		${3:attr} ${4:value}
	end
snippet sequence
	sequence(:${1:field}) { |i| ${2:value} }${3}
snippet fga attributes for
	FactoryGirl.attributes_for(:${1:name})
snippet fgb build unsaved model
	FactoryGirl.build(:${1:name})
snippet fgc create saved model
	FactoryGirl.create(:${1:name})
# before, around, after
snippet before validation
	before_validation ${1}
snippet after validation
	after_validation ${1}
snippet before save
	before_save ${1}
snippet after save
	after_save ${1}
snippet before create
	before_create ${1}
snippet around create
	around_create ${1}
snippet after create
	after_create ${1}
snippet before update
	before_update ${1}
snippet around update
	around_update ${1}
snippet after update
	after_update ${1}
snippet before destroy
	before_destroy ${1}
snippet after destroy
	after_destroy ${1}
snippet around destroy
	around_destroy ${1}
# filter
snippet before skip filter
	skip_before_filter :${1:method}
snippet before filter
	before_filter :${1:method}
snippet only
	only: [${1:methods}]
snippet except
	except: [${1:methods}]
snippet to_param
	def to_param
		"#{id}-#{${1:name}.parameterize}"
	end
snippet method method_missing
	def method_missing(method_name, *args, &block)
		@${1:instance}.send(method_name, *args, &block)
	end
snippet respond respond_to_missing?
	def respond_to_missing?(method_name, *args, &block)
		@${1:instance}.respond_to?(method_name, *args, &block)
	end
