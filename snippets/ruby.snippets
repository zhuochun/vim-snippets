########################################
# Ruby/Rails snippets
########################################
snippet enc
	# encoding: utf-8
	${1}
snippet #!
alias shebang
	#!/usr/bin/env ruby
	# encoding: utf-8
	${1}
snippet #! -wKU
	#!/usr/bin/env ruby -wKU
snippet env
	ENV.fetch('#{1:ENV_VARIABLE}') { ${2:default} }
snippet =b
	=begin rdoc
		${1}
	=end
snippet protected
	protected

	${1}
snippet private
	private

	${1}
snippet private_class_method
	private_class_method :${1:method}
snippet %q
	%q{${1:single quoted string}}
snippet %Q
	%Q{${1:double quoted string}}
snippet %w
	%w{${1:array of strings}}
snippet %W
	%W{${1:array of strings}}
snippet %r
	%r{${1:regular expression}}
snippet %s
	%s{${1:a symbol}}
snippet %i
	%i{${1:array of symbols}}
snippet stdin
alias gets
	$stdin.gets.chomp
snippet begin
alias beg
	begin
		${3:TARGET}
	rescue ${1:Exception} => ${2:e}
		${0:puts e.message}
	end
snippet rescue
	rescue ${1:Exception} => ${2:e}
		${0:puts e.message}
snippet ensure
	ensure
		${1:always executed}
snippet require
alias req
	require '${1}'${0}
snippet require_relative
alias reqr
	require_relative '${1}'${0}
snippet require_absolute
alias reqa
	require File.expand_path('../${1}', __FILE__)${0}
snippet load_path
	$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), *%w[${1:lib}]))${0}
snippet :
	${1:key}: ${2:'value'}
snippet #
	# =>
snippet lambda
	lambda { |${1:args}| ${2} }${0}
snippet ->
alias lam
	->(${1:args}) { ${2} }${0}
# block
snippet b
	{ |${1:var}| ${2} }${0}
snippet d
	do
		${1}
	end
snippet do
	do |${1:var}|
		${2}
	end
snippet yield
alias y
	yield
snippet block_given?
alias bg
	block_given?
# switches
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elif
alias eif el elseif
	elsif ${1:condition}
		${2}
snippet unless
alias un
	unless ${1:condition}
		${2}
	end
snippet while
alias wh
	while ${1:condition}
		${2}
	end
snippet for
	for ${1:e} in ${2:c}
		${3}
	end
snippet until
	until ${1:condition}
		${2}
	end
snippet loop
	loop { ${1} }
snippet loop do
	loop do
		${1}
	end
# memo
snippet memo basic
	@${1:variable} ||= ${2:method}
snippet memo unless defined?
	@${1:variable} = ${2:method} unless defined?(@$1)
snippet memo if defined?
	return @${1:variable} if defined?(@$1)
	${2}
snippet memo hash
	@${1:variable} ||= {}
	@$1[args] ||= ${2:method}(*args)
# class
snippet class
alias cla
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
	end
snippet class SubClass
alias cls
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ${2:ParentClass}
		${3}
	end
snippet class Struct
	${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end
	end
snippet class BlankSlate
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
	end
snippet class Self
alias claself
	class << ${1:self}
		${2}
	end
snippet class DelegateClass
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end
	end
snippet class Rails 3 ActiveModel
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		extend ActiveModel::Naming

		include ActiveModel::Conversion
		include ActiveModel::Validations

		attr_accessor :${1:attributes}

		def initialize(attributes = {})
			attributes.each do |name, value|
				send("#{name}=", value)
			end
		end

		def persisted?
			false
		end
	end
snippet class Rails 4 ActiveModel
alias clr
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		include ActiveModel::Model

		attr_accessor :${1:attributes}

		def initialize(attributes = {})
			attributes.each do |name, value|
				send("#{name}=", value)
			end
		end
	end
snippet class RuntimeError
	class ${1:NewExtented}Error < RuntimeError; end
snippet struct
	Struct.new(:${1:attr_name})
# module
snippet module
alias mod
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
	end
snippet module Concern ClassMethods
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		def self.included(base)
			base.extend ClassMethods
			base.class_eval do
				${2:scope :disabled -> { where(disabled: true) }}
			end
		end

		module ClassMethods
			${3}
		end

		def ${4:an_instance_method}
			${5:code}
		end
	end
snippet module Concern ActiveSupport
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		extend ActiveSupport::Concern

		included do
			${2:validates :example, presence: true}
		end

		module ClassMethods
			${3}
		end

		def ${4:an_instance_method}
			${5:code}
		end
	end
# attr_reader
snippet attr
	attr_reader :${1:attr_names}
# attr_writer
snippet attw
	attr_writer :${1:attr_names}
# attr_accessor
snippet attrw
	attr_accessor :${1:attr_names}
snippet attp
	attr_protected :${1:attr_names}
snippet atta
	attr_accessible :${1:attr_names}
snippet accepts_nested_attributes_for
	accepts_nested_attributes_for :${1:association}
snippet enum
	enum ${1:name}: %i[${2:option_1}, ${3:option_2}]
snippet const_get
	Object.const_get(${1:name}.capitalize)
# include
snippet include
alias inc
	include ${1:ActiveModel::Validations}
snippet extend
alias ext
	extend ${1:ActiveSupport::Memoizable}
# include Enumerable
snippet include enumerable
alias enumerable
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet include comparable
alias comparable
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet extend Forwardable
alias Forwardable
	extend Forwardable
# def
snippet def
	def ${1:method_name}
		${2}
	end
# def self
snippet def self.method
alias defs
	def self.${1:class_method_name}
		${2}
	end
# def initialize
snippet def init
alias defi init
	def initialize(${1:args})
		${0:code}
	end
# def method_missing and respond_to_missing?
snippet method_missing
	def method_missing(method_name, *args, &block)
		if ${0}
		else super
	end

	def respond_to_missing?(method_name, include_private = false)
		super
	end
# def respond_to_missing
snippet respond_to_missing?
	def respond_to_missing?(method_name, include_private = false)
		if ${0}
		else super
	end
# def const_missing
snippet const_missing
	def const_missing(const_name)
		if ${0}
		else super
	end
# delegator
snippet def_delegator
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet def_delegators
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet define_method
	define_method ${1:method_name} do
		${0:implementation}
	end
snippet define_method args
	define_method ${1:method_name} do |*args, &block|
		${0:implementation}
	end
snippet class_eval
	${1:klass}.class_eval do
		${0:implementation}
	end
snippet instance_eval
	${1:instance}.instance_eval do
		${0:implementation}
	end
snippet instance_variable_set
	instance_variable_set('@${1:variable}', ${2:value})
snippet refine
	refine ${1:String} do
		def ${2:method}
			${0:behaviour}
		end
	end
snippet alias_method
	alias_method :${1:new_name}, :${2:old_name}
# __
snippet __e
	__END__
snippet __f
	__FILE__
snippet __l
	__LINE__
# do something only if the code is being implicitly run, not required
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort 'Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}'${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort 'Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}'${3}
	end
# unix_filter {}
snippet unif
	ARGF.each_line(${1}) do |${2:line}|
		${3}
	end
# File/Dir
snippet file foreach
	File.foreach(${1:'path/to/file'}) do |${2:line}|
		${3}
	end
snippet file read
	File.read(${1:'path/to/file'})
snippet file dirname
	File.dirname(${1:__FILE__})
snippet file path
	File.join(File.dirname(__FILE__), '${1:path}')
snippet Dir glob
	Dir.glob(${1:'dir/glob/*'}) { |${2:file}| ${3} }
snippet Dir ['..']
	Dir[${1:'glob/**/*.rb'}]${2}
# Array/Hash
snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet set
	require 'set'
# methods
snippet delete_if
options word
	delete_if { |${1:e}| ${2} }
snippet fill
options word
	fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
snippet flao
options word
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
options word
	zip(${1:enums}) { |${2:row}| ${3} }
snippet tap
options word
	tap { |${1:obj}| ${2} }
snippet times
options word
	times { |${1:n}| ${2} }
snippet downto
options word
	downto(${1:0}) { |${2:n}| ${3} }
snippet step
options word
	step(${1:2}) { |${2:n}| ${3} }
snippet upto
options word
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
# Enumerable
snippet each
alias ea
options word
	each { |${1:e}| ${2} }
snippet each do
alias ead
options word
	each do |${1:e}|
		${2}
	end
snippet each_byte
options word
	each_byte { |${1:byte}| ${2} }
snippet each_char
options word
	each_char { |${1:chr}| ${2} }
snippet each_cons
options word
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet each_index
alias eai
options word
	each_index { |${1:i}| ${2} }
snippet each_index do
alias eaid
options word
	each_index do |${1:i}|
		${2}
	end
snippet each_key
alias eak
options word
	each_key { |${1:key}| ${2} }
snippet each_key do
alias eakd
options word
	each_key do |${1:key}|
		${2}
	end
snippet each_line
alias eal
options word
	each_line { |${1:line}| ${2} }
snippet each_line do
alias eald
options word
	each_line do |${1:line}|
		${2}
	end
snippet each_pair
options word
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet each_pair do
options word
	each_pair do |${1:name}, ${2:val}|
		${3}
	end
snippet each_slice
options word
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet each_slice do
options word
	each_slice(${1:2}) do |${2:group}|
		${3}
	end
snippet each_value
options word
	each_value { |${1:val}| ${2} }
snippet each_value do
options word
	each_value do |${1:val}|
		${2}
	end
snippet each_with_index
alias eawi
options word
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet each_with_index do
alias eawid
options word
	each_with_index do |${1:e}, ${2:i}|
		${3}
	end
snippet each_with_object
alias eawo
options word
	each_with_object(${1:obj}) { |${2:e}, ${3:memo}| ${4} }
snippet each_with_object do
alias eawod
options word
	each_with_object(${1:obj}) do |${2:e}, ${3:memo}|
		${4}
	end
snippet inject
options word
	inject(${1:init}) { |${2:memo}, ${3:var}| ${4} }
snippet inject do
options word
	inject(${1:init}) do |${2:memo}, ${3:var}|
		${4}
	end
snippet map
options word
	map { |${1:e}| ${2} }
snippet map method
options word
	map(&:${1:id})
snippet map do
options word
	map do |${1:e}|
		${2}
	end
snippet mapwi-
options word
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet all
options word
	all? { |${1:e}| ${2} }
snippet any
options word
	any? { |${1:e}| ${2} }
snippet classify
options word
	classify { |${1:e}| ${2} }
snippet collect
options word
	collect { |${1:e}| ${2} }
snippet collect do
options word
	collect do |${1:e}|
		${2}
	end
snippet detect
options word
	detect { |${1:e}| ${2} }
snippet detect do
options word
	detect do |${1:e}|
		${2}
	end
snippet drop_while
options word
	drop_while { |${1:e}| ${2} }
snippet fetch
options word
	fetch(${1:name}) { |${2:key}| ${3} }
snippet find
options word
	find { |${1:e}| ${2} }
snippet find do
options word
	find do |${1:e}|
		${2}
	end
snippet find_all
options word
	find_all { |${1:e}| ${2} }
snippet find_all do
options word
	find_all do |${1:e}|
		${2}
	end
snippet find_index
options word
	find_index { |${1:e}| ${2} }
snippet find_index do
options word
	find_index do |${1:e}|
		${2}
	end
snippet grep
options word
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet group_by
options word
	group_by { |${1:e}| ${2} }
snippet sub
options word
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet scan
options word
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet scan do
options word
	scan(${1:/pattern/}) do |${2:match}|
		${3}
	end
snippet max
options word
	max { |a, b| ${1} }
snippet min
options word
	min { |a, b| ${1} }
snippet minmax
options word
	minmax { |a, b| ${1} }
snippet partition
options word
	partition { |${1:e}| ${2} }
snippet partition do
options word
	partition do |${1:e}|
		${2}
	end
snippet reduce
options word
	reduce(${1:init}) { |${2:memo}, ${3:var}| ${4} }
snippet reduce do
options word
	reduce(${1:init}) do |${2:memo}, ${3:var}|
		${4}
	end
snippet reject
options word
	reject { |${1:e}| ${2} }
snippet reject do
options word
	reject do |${1:e}|
		${2}
	end
snippet reverse_each
alias reve
options word
	reverse_each { |${1:e}| ${2} }
snippet reverse_each do
alias reved
options word
	reverse_each do |${1:e}|
		${2}
	end
snippet select
alias filter
options word
	select { |${1:e}| ${2} }
snippet select do
options word
	select do |${1:e}|
		${2}
	end
snippet sort
options word
	sort { |a, b| ${1} }
snippet sort_by
options word
	sort_by { |${1:e}| ${2} }
snippet sort_by rand
options word
	sort_by { rand }
snippet take_while
options word
	take_while { |${1:e}| ${2} }
# option_parse {}
snippet optp
	require 'optparse'

	options = {${1:default: 'args'}}

	ARGV.options do |opts|
		opts.banner = 'Usage: #{File.basename($PROGRAM_NAME)}'
snippet opt
	opts.on('-${1:o}', '--${2:long-option-name}', ${3:String},
			'${4:Option description.}') do |${5:opt}|
		${6}
	end
# CSV
snippet csv foreach
	CSV.foreach(${1:file}, headers: true) do |row|
		${2:process row}
	end
# Marshal
snippet Marshal dump
	File.open(${1:'path/to/file.dump'}, 'wb') { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
snippet Marshal load
	File.open(${1:'path/to/file.dump'}, 'rb') { |${2:file}| Marshal.load($2) }${3}
snippet Marshal deep copy
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:'path/to/file'}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:'//Xpath'}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split('::').inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet singleton_class
	class << self; self end
# open io
snippet open
	open(${1:'path/or/url/or/pipe'}, '${2:w}') { |${3:io}| ${4} }
# common ruby exceptions
snippet err ArgumentError
	ArgumentError
snippet err IndexError
	IndexError
snippet err KeyError
	KeyError
snippet err IOError
	IOError
snippet err NameError
	NameError
snippet err NoMethodError
	NoMethodError
snippet err RangeError
	RangeError
snippet err TypeError
	TypeError
snippet err RuntimeError
	RuntimeError
snippet err ZeroDivisionError
	ZeroDivisionError

#############################################
# MiniTest
#############################################
snippet minitest
	require 'minitest/autorun'
	require './${1:class.rb}'

	class ${2:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < Minitest::Test
		${3}
	end
snippet minitest spec
	require 'minitest/autorun'
	require './${1:class.rb}'

	describe ${2:object} do
		${3}
	end
# Test Methods
snippet test rails
	test '${1:something}' do
		${2}
	end

#############################################
# Minitest Mock
#############################################
snippet mock
	${1:object} = MiniTest::Mock.new
snippet mock expect
	expect(${1:name}, ${2:val}, ${3:args = []})

#############################################
# TestCase in Rails
#############################################
snippet testcase
	require 'test_helper'

	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ActionController::TestCase
		test '${2}' do
			${3}
		end
	end

#############################################
# Rails API related
# https://labs.kollegorna.se/blog/2015/04/build-an-api-now/
#############################################
snippet api controller
	class API::${1:V1}::BaseController < ApplicationController
		protect_from_forgery with: :null_session

		before_action :destroy_session
		before_action :authenticate_user!

		protected

		def authenticate_user!
			token, options = ActionController::HttpAuthentication::Token.token_and_options(request)

			user_email = options.blank?? nil : options[:email]
			user = user_email && User.find_by(email: user_email)

			if user && ActiveSupport::SecurityUtils.secure_compare(user.authentication_token, token)
				@current_user = user
			else
				return unauthenticated!
			end
		end

		def destroy_session
			request.session_options[:skip] = true
		end
	end
snippet api route
	namespace :api do
		namespace :${1:v1} do
			${0}
		end
	end
snippet setup host
	setup { host! '${1:api.example.com}' }
snippet protect_from_forgery
alias forgery
	protect_from_forgery with: :null_session
snippet header
	self.headers['${1:WWW-Authenticate}'] = ${2:string}
snippet authenticate_with_http_basic
	authenticate_with_http_basic do |username, password|
		${1:User}.authenticate(username, password)
	end
snippet authenticate_with_http_token
	authenticate_with_http_token do |token, options|
		${1:User}.find_by(${2:auth_token}: token)
	end
snippet authenticate_or_request_with_http_basic
	authenticate_or_request_with_http_basic do |username, password|
		${1:User}.authenticate(username, password)
	end
snippet authenticate_or_request_with_http_token
	authenticate_or_request_with_http_token do |token, options|
		${1:User}.find_by(${2:auth_token}: token)
	end
snippet encode_credentials basic
	ActionController::HttpAuthentication::Basic.encode_credentials(${1:username}, ${2:password})
snippet encode_credentials token
	ActionController::HttpAuthentication::Token.encode_credentials(${1:token})
snippet get api
	get '${1:path}'
snippet get api accept
	get '${1:path}', {}, { 'Accept' => Mime::${2:JSON} }${0}
snippet get api authorization
	get '${1:path}', {}, { 'Authorization' => ${2:string}, 'Accept': Mime::${3:JSON} }${0}
snippet get api accept-language
	get '${1:path}', {}, { 'Accept-Language': '${2:en}', 'Accept': Mime::${3:JSON} }${0}
snippet post api
	post '${1:path}',
		{ ${2:model}: { ${3:contents} } }.to_json,
		{ 'Accept' => Mime::${4:JSON}, 'Content-Type' => Mime::JSON.to_s }
snippet patch api
	patch '${1:path}',
			{ ${2:model}: { ${3:contents} } }.to_json,
			{ 'Accept' => Mime::${4:JSON}, 'Content-Type' => Mime::JSON.to_s }
snippet delete api
	delete '${1:path}'

#############################################
# Response
#############################################
snippet response status
alias ress
	response.status
snippet response content_type
alias resc
	response.content_type
snippet response body
alias resb
	response.body

#############################################
# Response status
#############################################
snippet status 200 ok
	:ok
snippet status 201 created
	:created
snippet status 202 accepted
	:accepted
snippet status 203 non_authoritative_information
	:non_authoritative_information
snippet status 204 no_content
	:no_content
snippet status 301 moved_permanently
	:moved_permanently
snippet status 302 found
	:found
snippet status 304 not_modified
	:not_modified
snippet status 307 temporary_redirect
	:temporary_redirect
snippet status 308 permanent_redirect
	:permanent_redirect
snippet status 400 bad_request
	:bad_request
snippet status 401 unauthorized
	:unauthorized
snippet status 403 forbidden
	:forbidden
snippet status 404 not_found
	:not_found
snippet status 405 method_not_allowed
	:method_not_allowed
snippet status 406 not_acceptable
	:not_acceptable
snippet status 415 unsupported_media_type
	:unsupported_media_type
snippet status 422 unprocessable_entity
	:unprocessable_entity
snippet status 500 internal_server_error
	:internal_server_error

#############################################
# ActiveSupport
#############################################
snippet deprecate warn
	ActiveSupport::Deprecation.warn("${1:message}")
snippet deprecate method_warning
	ActiveSupport::Deprecation.deprecated_method_warning(${1:method_name}, ${2:message = nil})
snippet deprecate methods
	ActiveSupport::Deprecation.deprecate_methods(${1:target_module}, ${2:*method_names})

#############################################
# Assertions
#############################################
snippet assert
alias ass
	assert ${1:test}, '${2:Failure message.}'${3}
snippet assert_equal
	assert_equal ${1:expected}, ${2:actual}${3}
snippet assert_not_equal
	assert_not_equal ${1:unexpected}, ${2:actual}${3}
snippet assert_in_delta
	assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2 ** -20}${4}
snippet assert_instance_of
	assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}${3}
snippet assert_kind_of
	assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}${3}
snippet assert_nil
	assert_nil ${1:instance}${2}
snippet assert_not_nil
	assert_not_nil ${1:instance}${2}
snippet assert_match
	assert_match /${1:expected_pattern}/, ${2:actual_string}${3}
snippet assert_no_match
	assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}${3}
snippet assert_operator
	assert_operator ${1:left}, :${2:operator}, ${3:right}${4}
snippet assert_raise
	assert_raise ${1:Exception} { ${2} }
snippet assert_raise do
	assert_raise ${1:Exception} do
		${2}
	end
snippet assert_nothing_raised
	assert_nothing_raised ${1:Exception} { ${2} }
snippet assert_nothing_raised do
	assert_nothing_raised ${1:Exception} do
		${2}
	end
snippet assert_respond_to
	assert_respond_to ${1:object}, :${2:method}${3}
snippet assert_same
	assert_same ${1:expected}, ${2:actual}${3}
snippet assert_not_same
	assert_not_same ${1:unexpected}, ${2:actual}${3}
snippet assert_send
	assert_send [${1:object}, :${2:message}, ${3:args}]${4}
snippet assert_throws
	assert_throws :${1:expected} { ${2} }
snippet assert_throws do
	assert_throws :${1:expected} do
		${2}
	end
snippet assert_nothing_thrown
	assert_nothing_thrown { ${1} }
snippet assert_nothing_thrown do
	assert_nothing_thrown do
		${1}
	end
# rails assertions
snippet assert_routing
	assert_routing '${1:/path/}', { controller: '${2}', action: '${3}' }
snippet assert_redirected_to action
	assert_redirected_to ${1:action}: '${2:index}'}
snippet assert_redirected_to path
	assert_redirected_to ${1:parent}_path ${2}
snippet assert_difference
	assert_difference '${1:Model}.${2:count}', ${3:1} do
		${4}
	end
snippet assert_no_difference
	assert_no_difference '${1:Model}.${2:count}' do
		${3}
	end
snippet assert_response
	assert_response :${1:success}, @response.body${2}
snippet assert_rjs
	assert_rjs :${1:replace}, '${2:dom id}'
snippet assert_select
	assert_select '${1:path}', ${2:text}: '${3:inner_html' ${4:do}
snippet flunk
	flunk '${1:failure message}'
snippet skip
	skip '${1:skip message}'

#############################################
# Minitest Spec
#############################################
snippet must_be
options word
	must_be ${1}
snippet must_be_close_to
options word
	must_be_close_to ${1}
snippet must_be_empty
options word
	must_be_empty ${1}
snippet must_be_instance_of
options word
	must_be_instance_of ${1}
snippet must_be_kind_of
options word
	must_be_kind_of ${1}
snippet must_be_nil
options word
	must_be_nil ${1}
snippet must_be_same_as
options word
	must_be_same_as ${1}
snippet must_be_silent
options word
	must_be_silent ${1}
snippet must_be_within_delta
options word
	must_be_within_delta ${1}
snippet must_be_within_epsilon
options word
	must_be_within_epsilon ${1}
snippet must_equal
options word
	must_equal ${1}
snippet must_include
options word
	must_include ${1}
snippet must_match
options word
	must_match ${1}
snippet must_output
options word
	must_output ${1}
snippet must_raise
options word
	must_raise ${1}
snippet must_respond_to
options word
	must_respond_to ${1}
snippet must_send
options word
	must_send ${1}
snippet must_throw
options word
	must_throw ${1}
snippet wont_be
options word
	wont_be ${1}
snippet wont_be_close_to
options word
	wont_be_close_to ${1}
snippet wont_be_empty
options word
	wont_be_empty ${1}
snippet wont_be_instance_of
options word
	wont_be_instance_of ${1}
snippet wont_be_kind_of
options word
	wont_be_kind_of ${1}
snippet wont_be_nil
options word
	wont_be_nil ${1}
snippet wont_be_same_as
options word
	wont_be_same_as ${1}
snippet wont_be_within_delta
options word
	wont_be_within_delta ${1}
snippet wont_be_within_epsilon
options word
	wont_be_within_epsilon ${1}
snippet wont_equal
options word
	wont_equal ${1}
snippet wont_include
options word
	wont_include ${1}
snippet wont_match
options word
	wont_match ${1}
snippet wont_respond_to
options word
	wont_respond_to ${1}

#############################################
# Benchmark
#############################################
snippet benchmark_measure
options head
	puts Benchmark.measure do
		${1:code}
	end
snippet benchmark_bm
alias bm
options head
	require 'benchmark'

	times = ${1:50}_000.times
	Benchmark.bm do |x|
		x.report('${2:name}:') do
			times.each do
				${3:code}
			end
		end
	end
snippet benchmark_bmbm
alias bmbm
options head
	require 'benchmark'

	times = ${1:50}_000.times
	Benchmark.bmbm do |x|
		x.report('${2:name}:') do
			times.each do
				${3:code}
			end
		end
	end
snippet benchmark_report do
alias xre
options head
	x.report('${1:name}:') do
		${2:code}
	end
snippet benchmark_report
options head
	x.report('${1:name}:') { ${2:code} }

#############################################
# benchmark-ips
#############################################
snippet benchmark_ips
alias bmips
options head
	require 'benchmark/ips'

	Benchmark.ips do |x|
		x.config(time: ${1:3}.seconds, warmup: ${2:1}.seconds)

		x.report('${3:name}:') do
			${4:code}
		end

		x.compare!
	end
snippet benchmark_report time
options head
	x.report('${1:name}:') do |time|
		${2:code}
	end

#############################################
# debugging
#############################################
snippet byebug
options head
	byebug
snippet pry-remote
options head
	binding.remote_pry
snippet pry
options head
	binding.pry

#############################################
# bundler
#############################################
snippet gem
	source 'https://rubygems.org'

	ruby '${1:2.2.2}'

	${2:gem 'rspec', '~> 3.2.0'}
	${0}
snippet group
	group :${2:development} do
		${1:TARGET}
	end

#############################################
# rake
#############################################
snippet namespace rake
	namespace :${1:`vim_snippets#Filename()`} do
		${2}
	end
snippet task
	desc '${1:description}'
	task ${2:name}: [:${3:environment}] do
		${4}
	end
snippet task with args
	desc '${1:description}'
	task ${2:name}, [:${3:arg}] do |t, args|
		args.with_defaults($3: ${4})
		${5}
	end
snippet task with prerequisite args
	desc '${1:description}'
	task ${2:name}, [:${3:arg}] => [:${4:environment}] do |t, args|
		args.with_defaults($3: ${5})
		${6}
	end
snippet task file
	file '${1:output}' => ['${2:dependent}'] do |t|
		${3}
	end
snippet rake execute
	Rake::Task['${1:task_name}'].${2:execute}

#############################################
# Sinatra snippets
#############################################
snippet sinatra
	require 'sinatra'

	${1}

#############################################
# Rails model
#############################################
snippet belongs_to
	belongs_to :${1:association}
snippet belongs_to polymorphic
	belongs_to :${1:association}, polymorphic: true${2}
snippet has_and_belongs_to_many
	has_and_belongs_to_many :${1:associations}
snippet has_and_belongs_to_many join_table
	has_and_belongs_to_many :${1:associations}, join_table: '${2:table_name}', foreign_key: '${3}_id'${4}
snippet has_many
	has_many :${1:object}
snippet has_many class_name
	has_many :${1:other}s, class_name: '${2:$1}', foreign_key: '${3:$1}_id', dependent: :destroy${4}
snippet has_many through
	has_many :${1:object}, through: :${2:object}
snippet has_one
	has_one :${1:object}
snippet has_one dependent
	has_one :${1:object}, dependent: :${2:destroy}
# serialize text field
snippet serialize
	serialize :${1:preferences}, ${2:Hash}
# before, around, after
snippet before validation
	before_validation :${1:method}
snippet after validation
	after_validation :${1:method}
snippet before save
	before_save :${1:method}
snippet after save
	after_save :${1:method}
snippet before create
	before_create :${1:method}
snippet around create
	around_create :${1:method}
snippet after create
	after_create :${1:method}
snippet before update
	before_update :${1:method}
snippet around update
	around_update :${1:method}
snippet after update
	after_update :${1:method}
snippet before destroy
	before_destroy :${1:method}
snippet after destroy
	after_destroy :${1:method}
snippet around destroy
	around_destroy :${1:method}
# scope
snippet default_scope
alias defsco
	default_scope -> { ${1:scope} }
snippet scope ->
alias sco
	scope :${1:name}, -> { ${2:scope} }
snippet scope lambda
	scope :${1:name}, lambda do |${2:value}|
		${3:scope}
	end
# validations
snippet class Validator
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ActiveRecord::${2:Each}Validator
		def validate_each(record, attribute, value)
			if ${3:failed}
				record.errors[attribute] << (options[:message] || '${4:must have an error message}')
			end
		end
	end
snippet validate
	validate :${1:method}
snippet validates
	validates :${1:attribute}, ${2:validators}
snippet validates acceptance
	validates :${1:terms}, acceptance: true
snippet validates confirmation
	validates :${1:attribute}, confirmation: true
snippet validates exclusion
	validates :${1:attribute}, exclusion: { in: %w(${2: mov avi }) }
snippet validates format
	validates :${1:attribute}, format: { with: /\A${2:regex}\z/ }
snippet validates inclusion
	validates :${1:attribute}, inclusion: { in: %w(${2: mov avi }) }
snippet validates length in
	validates :${1:attribute}, length: { in: ${2:3}..${3:20} }
snippet validates length max
	validates :${1:attribute}, length: { maximum: ${2:255} }
snippet validates numericality
	validates :${1:attribute}, numericality: ${1:true}
snippet validates numericality greater_than_or_equal_to
	validates :${1:attribute}, numericality: ${1:true}, greater_than_or_equal_to: ${2:55}
snippet validates presence
	validates :${1:attribute}, presence: true
snippet validates uniqueness
	validates :${1:attribute}, uniqueness: true
snippet validates uniqueness scope
	validates :${1:attribute}, uniqueness: true, scope: :${2:attr}
snippet validates_associated
	validates_associated :${1:attribute}
snippet validates_with
	validates_with ${1:Some}Validator
# queries
snippet where
options word
	where(${1:field}: ${2:value})
snippet where condition
options word
	where('${1:condition = ?}', ${2:bind_var})
snippet order
options word
	order(${1:field}: :${2:desc})
snippet order desc
options word
	order('${1:field} ${2:DESC}')
snippet join merge
options word
	joins(:${1:models}).merge(${2:Model.scope})
snippet includes
options word
	includes(:${1:models})
snippet find_each
options word
	find_each(batch_size: ${1:5000}).do |${2:obj}}
		${3}
	end
snippet find_or_initialize_by
options word
	find_or_initialize_by(${1:field}: ${2:value})
snippet find_or_create_by
options word
	find_or_create_by(${1:attribute}: ${2:value})
snippet find_by_sql
	find_by_sql <<-SQL
		${1:SQL}
	SQL
snippet persisted?
	@${1:model}.persisted?${0}
snippet new_record?
	@${1:model}.new_record?${0}
# transaction
snippet transaction
	ActiveRecord::Base.transaction do
		${1:TARGET}
	end
snippet transaction model
	${1:@model}.class.transaction do
		${2:operation}
	end
# ActiveRecord exceptions
snippet raise RecordInvalid
	raise ActiveRecord::RecordInvalid${0}
snippet raise RecordNotFound
	raise ActiveRecord::RecordNotFound${0}
snippet raise Rollback
	raise ActiveRecord::Rollback${0}

#############################################
# Rails controller
#############################################
snippet defindex
	# GET /$1
	# GET /$1.json
	def index
		@${1:model_class_name} = ${2:ModelClassName}.all

		respond_to do |format|
			format.html # index.html.erb
			format.json { render json: @$1s }
		end
	end
snippet defnew
	# GET /$1/new
	# GET /$1/new.json
	def new
		@${1:model_class_name} = ${2:ModelClassName}.new

		respond_to do |format|
			format.html # new.html.erb
			format.json { render json: @$1 }
		end
	end
snippet defcreate
	# POST /$1
	# POST /$1.json
	def create
		@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])${0}

		respond_to do |format|
			if @$1.save
				format.html { redirect_to @$1, notice: '$2 was successfully created.' }
				format.json { render json: @$1, status: :created, location: @$1 }
			else
				format.html { render action: 'new' }
				format.json { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end
snippet defshow
	# GET /$1/1
	# GET /$1/1.json
	def show
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])${0}

		respond_to do |format|
			format.html # show.html.erb
			format.json { render json: @$1 }
		end
	end
snippet defedit
	# GET /$1/1/edit
	def edit
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])${0}
	end
snippet defupdate
	# PUT /$1/1
	# PUT /$1/1.json
	def update
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])${0}

		respond_to do |format|
			if @$1.update_attributes(params[:$1])
				format.html { redirect_to @$1, notice: '$2 was successfully updated.' }
				format.json { head :no_content }
			else
				format.html { render action: 'edit' }
				format.json { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end
snippet defdestroy
	# DELETE /$1/1
	# DELETE /$1/1.json
	def destroy
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])${0}
		@$1.destroy

		respond_to do |format|
			format.html { redirect_to $1s_url }
			format.json  { head :no_content }
		end
	end
snippet flash
	flash[:${1:notice}] = '${2}'
snippet add_flash_types
	add_flash_types :${1:warning}
snippet content_tag
	content_tag :${1:div}, ${2:content}, ${3:options}
snippet content_tag do
	content_tag :${1:div}, ${2:options} do
		${3:content}
	end
snippet params
	params[:${1:id}]${2}
snippet params require
	params.require(:${1:model}).permit(:${2:fields})
snippet params def
	def ${1:model}_params
		params.require(:$1).permit(:${2:fields})
	end
snippet sha1
	Digest::SHA1.hexdigest(${1:string})
snippet base64
	Base64.encode64(${1:string})
# i18n
snippet i18n translate
alias i18t
	I18n.t('${1:type.key}')${2}
snippet i18 translate shorthand
alias t
	t('${1:type.key}')
snippet i18n localize
alias i18l
	I18n.l('${1:type.key}')${2}
snippet i18 localize shorthand
alias l
	l('${1:type.key}')${2}
# Logger
snippet logger
	logger = Logger.new(STDOUT)
	logger.level = Logger::INFO
snippet log
	logger.${2:debug} ${3}
snippet lod
	logger.debug { '${1:message}' }
snippet loe
	logger.error { '${1:message}' }
snippet lof
	logger.fatal { '${1:message}' }
snippet loi
	logger.info { '${1:message}' }
snippet low
	logger.warn { '${1:message}' }
snippet rails log
	Rails.logger.info { '${1:message}' }
# Map
snippet mapc
	${1:map}.${2:connect} '${3:controller/:action/:id}'
snippet mapca
	${1:map}.catch_all '*${2:anything}', controller: '${3:default}', action: '${4:error}'${5}
snippet mapr
	${1:map}.resource :${2:resource}
snippet maprs
	${1:map}.resources :${2:resource}
snippet mapwo
	${1:map}.with_options ${2:controller}: '${3:thing}' do |$3|
		${4}
	end
# respond_to
snippet respond_to
	respond_to :${1:json}
snippet respond_to do
	respond_to do |format|
		format.${1:html} { ${2} }
		format.${3:json} { render json: ${4:json_data}, status: :ok }
	end
snippet format
	format.${1:js|xml|html} { ${2} }
# active_model_serializers
snippet format json
	format.json { render json: @${1:model}, serializer: ${2:Serializer}, status: ${3:status} }
# render
snippet render action
alias ra
	render action: '${1:action}'
snippet render action layout
alias ral
	render action: '${1:action}', layout: '${2:layoutname}'
snippet render file
alias rf
	render file: '${1:filepath}'
snippet render file full_path
alias rfu
	render file: '${1:filepath}', use_full_path: ${2:false}
snippet render inline
alias ri
	render inline: '${1:<%= 'hello' %>}'
snippet render inline locals
alias ril
	render inline: '${1:<%= 'hello' %>}', locals: { ${2::name}: '${3:value}'${4} }
snippet render inline type
alias rit
	render inline: '${1:<%= 'hello' %>}', type: ${2::rxml}
snippet render xml
alias rxml
	render xml: ${1:text to render}
snippet render json
alias rjson
	render json: ${1:text to render}
snippet render layout
alias rl
	render layout: '${1:layoutname}'
snippet render nothing
alias rn
	render nothing: ${1:true}
snippet render nothing status
alias rns
	render nothing: ${1:true}, status: ${2:401}
snippet render partial
alias rp
	render partial: '${1:item}'
snippet render partial collection
alias rpc
	render partial: '${1:item}', collection: ${2:@$1s}
snippet render partial locals
alias rpl
	render partial: '${1:item}', locals: { ${2:$1}: ${3:@$1} }
snippet render partial object
alias rpo
	render partial: '${1:item}', object: ${2:@$1}
snippet render partial status
alias rps
	render partial: '${1:item}', status: ${2:500}
snippet render text
alias rt
	render text: '${1:text to render}'
snippet render text layout
alias rtl
	render text: '${1:text to render}', layout: '${2:layoutname}'
snippet render text status
alias rts
	render text: '${1:text to render}', status: ${2:401}
snippet render update do
alias ru
	render :update do |${1:page}|
		$1.${2}
	end
# xhr
snippet xdelete
	xhr :delete, :${1:destroy}, id: ${2:1}${3}
snippet xget
	xhr :get, :${1:show}, id: ${2:1}${3}
snippet xpost
	xhr :post, :${1:create}, ${2:object}: { ${3} }
snippet xput
	xhr :put, :${1:update}, id: ${2:1}, ${3:object}: { ${4} }${5}
# filter
snippet before skip filter
	skip_before_filter :${1:method}
snippet before filter
	before_filter :${1:method}
snippet before action
	before_action :${1:method}
snippet after action
	after_action :${1:method}
snippet rescue_from
	rescue_from ${1:ActiveRecord::RecordNotFound}, with: :${2:method}
snippet only
	only: [${1:methods}]
snippet except
	except: [${1:methods}]

#############################################
# Rails cache
#############################################
snippet cache fetch
	Rails.cache.fetch(${1:cache_key}) { ${2:block} }
snippet cache fetch do
alias caf
	Rails.cache.fetch(${1:cache_key}) do
		${2:TARGET}
	end
snippet cache fetch expires_in
	Rails.cache.fetch(${1:cache_key}, expires_in: ${2:30.minutes}, race_condition_ttl: ${3:5.seconds}) do
		${4:TARGET}
	end
snippet cache read
	Rails.cache.read(${1:key})
snippet cache write
	Rails.cache.write(${1:key}, ${2:value})
snippet cache delete
	Rails.cache.delete(${1:key})
snippet cache clear
	Rails.cache.clear
snippet sweeper
	class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper
		observe $1

		def after_save(${2:model_class_name})
			expire_cache($2)
		end

		def after_destroy($2)
			expire_cache($2)
		end

		def expire_cache($2)
			expire_page
		end
	end

#############################################
# ActiveSupport
#############################################
snippet to_param
	def to_param
		"#{id}-#{${1:name}.parameterize}"
	end
snippet with_options
	with_options only: [:${1:index}] do |list|
		list.${2:resources} :${3:model}
	end
snippet alias_method_chain
	def ${1:method}_with_${2:feature}(${3:args})
		result = $1_without_$2($3)
		${0:code}
	end
	alias_method_chain :$1, :$2
snippet alias_attribute
	alias_attribute :${1:new_name}, :${2:old_name}
snippet delegate
	delegate :${1:methods}, to: :${2:object}
snippet delegate with prefix
	delegate :${1:methods}, to: :${2:object}, prefix: ${3:true}
snippet delegate and allow_nil
	delegate :${1:methods}, to: :${2:object}, allow_nil: ${3:true}

#############################################
# Rails Route
#############################################
snippet root to
	root to: '${1:home#index}'
snippet post to
	post '${1:path}', to: '${2:controller}#${3:action}'
snippet get to
	get '${1:path}', to: '${2:controller}#${3:action}'
snippet patch to
	patch '${1:path}', to: '${2:controller}#${3:action}'
snippet resources
	resources :${1:model}
snippet resources controller
	resources :${1:model}, controller: '${2:demo/controllers}'
snippet resources only
	resources :${1:model}, only: [:${2:methods}]
snippet resources except
	resources :${1:model}, except: [:${2:methods}]
snippet resources constraints
	resources :${1:model}, constraints: { subdomain: '${2:api}' }
snippet resources constraints block
	constraints subdomain: '${1:api}' do
		namespace :${2:v1} do
			${3:resources} :${4:model}
		end
	end
snippet namespace rails_route
	namespace :${1:module} do
		resources :${2:model}
	end
snippet namespace rails_route constraints
	namespace :${1::v1}, constraints: { subdomain: '$1' } do
		resources :${2:model}
	end
snippet concern rails_route
	concern :${1:concernable} do |options|
		resources :${2:model}, options
	end

#############################################
# Rails Migrations
#############################################
snippet create_table
	change_table :${1:table_name} do |t|
		${2}
	end
snippet add_column
	add_column :${1:table_name}, :${2:column_name}, :${3:data_type}
snippet add_index
	add_index :${1:table_name}, :${2:column_name}
snippet remove_column
	remove_column :${1:table_name}, :${2:column_name}
snippet rename_column
	rename_column :${1:table_name}, :${2:old_column_name}, :${3:new_column_name}
snippet change_column
	change_column :${1:table}, :${2:column}, :${3:type}
snippet migration up_down
	class ${1:class_name} < ActiveRecord::Migration
		def up
			${2}
		end

		def down
		end
	end
snippet migration change
	class ${1:class_name} < ActiveRecord::Migration
		def change
			${2}
		end
	end
snippet trc
	t.remove :${1:column}
snippet tre
	t.rename :${1:old_column_name}, :${2:new_column_name}
snippet tref
	t.references :${1:model}
snippet tref polymorphic
	t.references :${1:taggable}, polymorphic: { default: '${2:Photo}' }
snippet tstr
	t.string :${1:title}${2:, null: false}
snippet tboo
	t.boolean :${1:title}
snippet tbin
	t.binary :${1:title}, :limit => ${2:2}.megabytes
snippet tdec
	t.decimal :${1:title}, :precision => ${2:10}, :scale => ${3:2}
snippet tdate
	t.date :${1:title}
snippet ttime
	t.time :${1:title}
snippet tdatt
	t.datetime :${1:title}
snippet tflo
	t.float :${1:title}
snippet tint
	t.integer :${1:title}
snippet tint lock_version
	t.integer :lock_version, :null => false, :default => 0
snippet ttext
	t.text :${1:title}
snippet ttimestamp
	t.timestamp :${1:title}
snippet ttimestamps
	t.timestamps
snippet tchange
	t.change :${1:name}, :${2:string}, :${3:limit} => ${4:80}

##########################
# Rspec snippets
##########################
snippet rspec unit
	require 'spec_helper'

	describe '${1:a behaviour}' do
		${2:pending 'Not implemented'}
	end
snippet rspec feature
	require 'spec_helper'

	feature '${1:an action}' do
		${2:pending 'Not implemented'}
	end
snippet describe
alias desc
	describe ${1:name} do
		${2:pending 'Not implemented'}
	end
snippet desc rspec
	RSpec.describe ${1:name} do
		${2:pending 'Not implemented'}
	end
snippet desc instance method
	describe '#${1:instance_method}' do
		${2:pending 'Not implemented'}
	end
snippet desc class method
	describe '.${1:class_method}' do
		${2:pending 'Not implemented'}
	end
snippet context
alias cont
	context '${1:when something happened}' do
		${2}
	end
snippet it
	it '${1:does something}' do
		${2}
	end
snippet specify
	specify { subject.${1} }
snippet bef
	before { ${1} }
snippet befd
	before do
		${1}
	end
snippet before each
	before :${1:each} do
		${2}
	end
snippet after each
	after :${1:each} do
		${2}
	end
snippet let
	let(:${1:object}) { ${2} }
snippet let!
	let!(:${1:object}) { ${2} }
snippet subj
	subject { ${1} }
snippet subj name
	subject(:${1:instance}) { ${2} }
# shared examples
snippet shared_examples
	shared_examples '${1:shared example name}' do
		${2:pending 'Not implemented'}
	end
snippet shared_examples args
	shared_examples '${1:shared example name}' do |${2:args}|
		${3:pending 'Not implemented'}
	end
snippet it_behaves_like
	it_behaves_like '${1:shared example name}'

##########################
# RSpec Expects
##########################
# equal
snippet expto_eq
	expect(${1:target}).to eq(${2})
snippet expto_not_eq
	expect(${1:target}).to_not eq(${2})
snippet expto_eql
	expect(${1:target}).to eql(${2})
snippet expto_not_eql
	expect(${1:target}).to_not eql(${2})
snippet expto_equal
	expect(${1:target}).to equal(${2})
snippet expto_not_equal
	expect(${1:target}).to_not equal(${2})
# be
snippet expto_be
	expect(${1:target}).to be(${2})
snippet expto_not_be
	expect(${1:target}).to_not be(${2})
snippet expto_be_true
	expect(${1:target}).to be_true
snippet expto_be_false
	expect(${1:target}).to be_false
snippet expto_be_nil
	expect(${1:target}).to be_nil
snippet expto_be_within
	expect(${1:target}).to be_within(${2:0.1}).of(${3:1.9})
snippet expto_be_a
	expect(${1:target}).to be_a(${2:type})
snippet expto_be_instance_of
	expect(${1:target}).to be_an_instance_of(${2:type})
# arrays
snippet expto_include
	expect(${1:target}).to include(${2:itemA, itemB})
snippet expto_match_array
	expect(${1:target}).to match_array(${2:[]})
snippet expto_contain_exactly
	expect(${1:target}).to contain_exactly(${2:itemA, itemB})
# exists
snippet expto_exist
	expect(${1:target}).to exist
# range change
snippet expto_change
	expect { ${1:action} }.to change{ ${2:behaviour} }
snippet expto_change_by
	expect do
		${1:action}
	end.to change{ ${2:target.behaviour} }.by(${3:1})
snippet expto_change_from_to
	expect do
		${1:action}
	end.to change{ ${2:target.behaviour} }.from(${3:old_state}).to(${4:new_state})
# exception/error
snippet expto_raise_error
	expect do
		${1:action}
	end.to raise_error(${2:SystemExit})
snippet expto_raise_exception
	expect do
		${1:action}
	end.to raise_exception(${2:SystemExit})
# match
snippet expto_match
	expect(${1:target}).to match(${2})
# response to
snippet expto_response_to
	expect(${1:target}).to respond_to(:${2:method})
# satisfy
snippet expto_satisfy
	expect(${1:target}).to satisfy { |${2:obj}| ${3} }
# output
snippet expto_output
	expect do
		${1:target}
	end.to output('${2:message}').to_stdout
# yield control
snippet expto_yield
	expect do |block|
		${1:target(&block)}
	end.to yield_control
snippet expto_yield_exactly_times
	expect do |block|
		${1:target(&block)}
	end.to yield_control.exactly(${2:2}).times
# rspec rails
snippet expto_be_a_new
	expect(${1:obj}).to be_a_new(${2:Object})
snippet expto_render_template
	expect(${1:response}).to render_template(${2:'new'})
snippet expto_render_partial_template
	expect(${1:response}).to render_template(partial: ${2:'_form'}, locals: { ${3} })
snippet expto_redirect_to
	expect(${1:response}).to redirect_to(${2:path})
snippet expto_response_with
	expect(${1:response.status}).to eq(${2:200})
snippet expto_have_http_status
	expect(${1:response}).to have_http_status(${2:200})
# mock and stub
snippet all_to_receive_and_return
	allow(${1:mock}).to receive(:${2:method}).and_return(${3:result})
snippet all_to_receive_with_and_return
	allow(${1:mock}).to receive(:${2:method}).with(${3:args}).and_return(${4:result})
snippet all_to_receive_and_return block
	allow(${1:mock}).to receive(:${2:method}) { ${3:result} }
snippet all_to_receive_message_chain
	allow(${1:mock}).to receive_message_chain(:${2:method1}, :${3:method2})
snippet all_any_instance_to_receive
	allow_any_instance_of(${1:Class}).to receive(:${2:method}) { ${3:result} }
# instance.stub (Deprecated)
snippet stub
options word
	stub(${1:method}: ${2:return})
snippet stub returns
options word
	stub(:${1:method}).and_return(${3:return_value})
snippet stub chain
options word
	stub_chain(:${1:one}, :${2:two}).and_return(${3:return_value})
snippet stub instance
options word
	any_instance.stub(:${1:method}).and_return(${2:return_value})
# expect spies/doubles
snippet expto_have_received
	expect(${1:obj}).to have_received(:${2:method})
snippet expto_have_received_with
	expect(${1:obj}).to have_received(:${2:method}).with(${3:args})
snippet exp_any_instance_of_receive
	expect_any_instance_of(${1:Object}).to receive(:${2:method})
snippet expto_receive_once
	expect(${1:obj}).to receive(:${2:method}).once
snippet expto_receive_twice
	expect(${1:obj}).to receive(:${2:method}).twice
snippet expto_receive_exactly_times
	expect(${1:obj}).to receive(:${2:method}).exactly(${3:3}).times
snippet expto_receive_at_least_times
	expect(${1:obj}).to receive(:${2:method}).at_least(${3:3}).times
snippet expto_receive_at_most_times
	expect(${1:obj}).to receive(:${2:method}).at_most(${3:3}).times
snippet expto_receive_any_number_of_times
	expect(${1:obj}).to receive(:${2:method}).any_number_of_times
snippet expto_receive_with
	expect(${1:obj}).to receive(:${2:method}).with(${3:args})
snippet expto_receive_with_and_return
	expect(${1:obj}).to receive(:${2:method}).with(${3:args}).and_return(${4:result})
snippet expto_receive_with_an_instance_of
	expect(${1:obj}).to receive(:${2:method}).with(an_instance_of(${3:Object}))
snippet expto_receive_with_hash
	expect(${1:obj}).to receive(:${2:method}).with(hash_including(${3:key: val}))
snippet expto_receive_with_anything
	expect(${1:obj}).to receive(:${2:method}).with(anything())
snippet expto_receive_and_raise
	expect(${1:obj}).to receive(:${2:method}).and_raise('${3:an error}')
snippet expto_receive_and_call_original
	expect(${1:obj}).to receive(:${2:method}).and_call_original

#############################################
# shoulda-matchers
#############################################
snippet itisexpto
	it { is_expected.to ${1} }
# ActiveModel Matchers
snippet itisexpto_allow_mass_assignment_of
	it { is_expected.to allow_mass_assignment_of(:${1:attr}) }
snippet itisexpto_allow_value
	it { is_expected.to allow_value(${1:values}).for(:${2:attr}) }
snippet itisexpto_not_allow_value
	it { is_expected.to_not allow_value(${1:values}).for(:${2:attr}) }
snippet itisexpto_have_secure_password
	it { is_expected.to have_secure_password }
snippet itisexpto_validate_acceptance_of
	it { is_expected.to_not validate_acceptance_of(:${1:attr}) }
snippet itisexpto_validate_confirmation_of
	it { is_expected.to validate_confirmation_of(:${1:attr}) }
snippet itisexpto_validate_exclusion_of
	it { is_expected.to validate_exclusion_of(:${1:attr}).in_array(%w[${2}]) }
snippet itisexpto_validate_inclusion_of
	it { is_expected.to validate_inclusion_of(:${1:attr}).in_array(%w[${2}]) }
snippet itisexpto_ensure_length_is_at_least
	it { is_expected.to ensure_length_of(:${1:attr}).is_at_least(${2:3}) }
snippet itisexpto_ensure_length_is_at_most
	it { is_expected.to ensure_length_of(:${1:attr}).is_at_most(${2:255}) }
snippet itisexpto_validate_length_is_at_least
	it { is_expected.to validate_length_of(:${1:attr}).is_at_least(${2:3}) }
snippet itisexpto_validate_length_is_at_most
	it { is_expected.to validate_length_of(:${1:attr}).is_at_most(${2:255}) }
snippet itisexpto_validate_numericality_of
	it { is_expected.to validate_numericality_of(:${1:attr}) }
snippet itisexpto_validate_numericality_of_greater_than
	it { is_expected.to validate_numericality_of(:${1:attr}).is_greater_than_or_equal_to(${2:55}) }
snippet itisexpto_validate_presence_of
	it { is_expected.to validate_presence_of(${1}) }
# ActiveRecord Matchers
snippet itisexpto_accept_nested_attributes_for
	it { is_expected.to accept_nested_attributes_for(:${1:name}) }
snippet itisexpto_belong_to
	it { is_expected.to belong_to(:${1:name}) }
snippet itisexpto_define_enum_for
	it { is_expected.to define_enum_for(:${1:name}).with(%i[${2}]) }
snippet itisexpto_have_and_belong_to_many
	it { is_expected.to have_and_belong_to_many(:${1:name}) }
snippet itisexpto_have_db_column
	it { is_expected.to have_db_column(:${1:name}).of_type(:${2:string}) }
snippet itisexpto_have_db_index
	it { is_expected.to have_db_index(:${1:name}) }
snippet itisexpto_have_many
	it { is_expected.to have_many(:${1:name}) }
snippet itisexpto_have_one
	it { is_expected.to have_one(:${1:name}) }
snippet itisexpto_have_readonly_attribute
	it { is_expected.to have_readonly_attribute(:${1:name}) }
snippet itisexpto_serialize
	it { is_expected.to serialize(:${1:name}).as(${2:Array}) }
snippet itisexpto_validate_uniqueness_of
	it { is_expected.to validate_uniqueness_of(:${1:attr}) }
# ActionController Matchers
snippet itisexpto_filter_param
	it { is_expected.to filter_param(:${1:param}) }
snippet itisexpto_permit
	it { is_expected.to permit(:${1:param}).for(:${2:create}) }
snippet itisexpto_redirect_to
	it { is_expected.to redirect_to(${1:url}) }
snippet itisexpto_render_template
	it { is_expected.to render_template(${1:name}) }
snippet itisexpto_render_with_layout
	it { is_expected.to render_with_layout(${1:name}) }
snippet itisexpto_rescue_from
	it { is_expected.to rescue_from(${1:ActiveRecord::RecordNotFound}).with(${2:method}) }
snippet itisexpto_respond_with
	it { is_expected.to respond_with(${1:status_code}) }
snippet itisexpto_route
	it { is_expected.to route(:${1:get}, '${2:path}').to(action: ${3:index}, ${params}) }
snippet itisexpto_set_flash
	it { is_expected.to set_flash[:${1:key}] }
snippet itisexpto_set_session
	it { is_expected.to set_session[:${1:key}] }
snippet itisexpto_use_after_action
	it { is_expected.to use_after_action(:${1:callback}) }
snippet itisexpto_use_around_action
	it { is_expected.to use_around_action(:${1:callback}) }
snippet itisexpto_use_before_action
	it { is_expected.to use_before_action(:${1:callback}) }
# Other Matchers
snippet itisexpto_respond_to
	it { is_expected.to respond_to(:${1:method}) }
snippet itisexpto_match
	it { is_expected.to match(/${1:regex}/) }
snippet itisexpto_respond_with_content_type
	it { is_expected.to respond_with_content_type(:${1:json}) }
snippet itisexpto_delegate_method
	it { is_expected.to delegate_method(${1}) }

#############################################
# TomDoc
#############################################
snippet doc method
	# ${1:Public/Internal/Deprecated}: ${2:what does it do?}
	#
	# ${3:args - Description}
	#
	# Examples
	#
	# ${4:bar()}
	#
	# ${5:Returns nothing.}
snippet doc class/module
	# ${1:Public/Internal/Deprecated}: ${2:what does it do?}
	#
	# Examples
	#
	# ${3:bar()}
snippet doc constant
	# ${1:Public/Internal/Deprecated}: [${2:Type}] ${3:its purpose}
snippet doc argument
	${1:arg} - ${2:description}
snippet doc argument with default
	${1:arg} - ${2:description}(default: ${3})
snippet doc returns
	Returns ${1}

# regex
snippet rgx
	%r{
		${1}
	}x
snippet rgx named_group
	(?<${1:name}>${2:regex})
snippet lookahead positive
	(?=${1})
snippet lookahead negative
	(?!${1})
snippet lookbehind positive
	(?<=${1})
snippet lookbehind negative
	(?<!${1})

# to_json
snippet to_json only
options word
	to_json(include: ${1}, only: ${2})
snippet to_json except
options word
	to_json(include: ${1}, except: ${2})

# Here Document
snippet heredoc
alias <<
	<<-${1:EOS}
		${2}
	$1
snippet heredoc strip
	<<-${1:END}.strip_heredoc
		${2}
	$1
snippet heredoc sql
	<<-SQL
		${1}
	SQL
snippet heredoc eof
	<<-EOF
		${1}
	EOF

#############################################
# capybara cheatsheet
#############################################
snippet feature
alias fea
	feature '${1:an action}' do
		${2:pending 'Not implemented'}
	end
snippet background
alias bac
	background do
		${1}
	end
snippet scenario
alias sce
	scenario '${1:use case}' do
		${2}
	end
snippet scenario js
	scenario '${1:use case}', js: true do
		${2}
	end
snippet expto_have_text
	expect(page).to have_text(${1})
snippet expto_have_content
	expect(page).to have_content(${1})
snippet expto_have_selector
	expect(page).to have_selector(${1})
snippet expto_have_xpath
	expect(page).to have_xpath(${1})
snippet expto_have_css
	expect(page).to have_css(${1})
snippet expto_current_path_eq
	expect(current_path).to eq(${1})
snippet expto_checkbox_checked
	expect(find('${1:.checkbox}').checked?).to be_true
snippet visit
	visit ${1:path}
snippet execute_script
	execute_script '${1:javascript}'
snippet click_link
	click_link ${1:id/text}
snippet click_button
	click_button ${1:id/text}
snippet click_on
	click_on ${1:id/text}
snippet fill_in
	fill_in '${1:field}', with: ${2:value}
snippet choose radio button
	choose '${1:a radio button}'
snippet check checkbox
	check '${1:a checkbox}'
snippet uncheck checkbox
	uncheck '${1:a checkbox}'
snippet select dropdown
	select '${1:option}', from: '${2:field}'
snippet unselect dropdown
	unselect '${1:option}', from: '${2:field}'
snippet attach_file
	attach_file '${1:field}', '${2:path_to_file}'
snippet find default
	find('${1:selector}').${2:action}
snippet find click on
	find('${1:selector}').click_on('${2:link}')
snippet find_field
	find_field('${1:selector}').${2:action}
snippet find_link
	find_link('${1:text}').${2:action}
snippet find_button
	find_button('${1:text}').${2:action}
snippet within
	within '${1:selector}' do
		${2}
	end

#############################################
# FactoryGirl
#############################################
snippet fg
	FactoryGirl.${1:build_stubbed}(:${2:model})
snippet factory define
alias fgd
	FactoryGirl.define do
		factory :${1:name} do
			${2:attr} ${3:value}
		end
	end
snippet factory default
alias fgdf
	factory :${1:name} do
		${2:attr} ${3:value}
	end
snippet factory class
alias fgc
	factory :${1:name}, class: ${2:Model} do
		${3:attr} ${4:value}
	end
snippet factory trait
	factory :${1}, traits: [:${2:trait}]
snippet factory has_many
	factory :${1:model}_with_${2:many}s do
		ignore do
			$2s_count 5
		end

		after(:create) do |$1, evaluator|
			create_list(:$2, evaluator.$2s_count, $1: $1)
		end
	end
snippet attributes for
	attributes_for(:${1:name})
snippet sequence
alias seq
	sequence(:${1:field}) { |i| ${2:value} }
snippet association
alias ass
	association :${1:attr}, factory: :${2:model}
snippet build
alias strategy
	strategy: :build
snippet trait
	trait :${1:name} do
		${2}
	end
snippet create_list
	create_list(:${1:of_model}, ${2:count}, ${3:to_model}: $3)
snippet build_list
	build_list(:${1:of_model}, ${2:count}, ${3:to_model}: $3)

#############################################
# timecop gem
#############################################
snippet time freeze do
	Timecop.freeze(${1:Time.now}) do
		${2:code}
	end
snippet time freeze
	Timecop.freeze(${1:Time.now})
snippet time unfreeze
	Timecop.return

#############################################
# cancan gem
#############################################
snippet can manage
	can? :manage, ${1:Model}
snippet can read
	can? :read, ${1:Model}
snippet can create
	can? :create, ${1:Model}
snippet can update
	can? :update, ${1:Model}
snippet can destroy
	can? :destroy, ${1:Model}
snippet can customize
	can? :${1:view}, ${2:Model}

#############################################
# pundit gem
#############################################
snippet policy
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ApplicationPolicy
		${2}
	end
snippet policy application
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		attr_reader :user, :${2:record}

		def initialize(user, $2)
			@user = user
			@$2 = $2
		end

		${3}
	end
