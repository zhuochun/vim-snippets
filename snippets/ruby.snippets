########################################
# Ruby snippets - for Rails, see below #
########################################

# encoding for Ruby 1.9
snippet enc
	# encoding: utf-8
	${1}

# #!/usr/bin/env ruby
snippet #!
alias shebang
	#!/usr/bin/env ruby
	# encoding: utf-8
	${1}

# New Block
snippet =b
	=begin rdoc
		${1}
	=end
snippet protected
	protected

	${1}
snippet private
	private

	${1}
snippet yield
alias y
	yield
snippet block_given
alias bg
	block_given?
snippet rb
	#!/usr/bin/env ruby -wKU
snippet beg
	begin
		${3}
	rescue ${1:Exception} => ${2:e}
	end
snippet require
alias req
	require '${1}'${2}
snippet require_relative
alias reqr
	require_relative '${1}'${2}
snippet :
	${1:key}: ${2:'value'}
snippet #
	# =>
snippet end
	__END__
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elseif
alias eif el
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
alias wh
	while ${1:condition}
		${2}
	end
snippet for
	for ${1:e} in ${2:c}
		${3}
	end
snippet until
	until ${1:condition}
		${2}
	end
snippet memo basic
	@${1:variable} ||= ${2:method}
snippet memo false or nil
	@${1:variable} = ${2:method} unless defined?(@$1)
snippet memo hash
	@${1:variable} ||= {}
	@$1[args] ||= ${2:method}(*args)
snippet class basic
alias cla
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
	end
snippet class initialize
alias cli
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		def initialize(${2:args})
			${3}
		end
	end
snippet class SubClass
alias cls
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end
	end
snippet class Struct
	${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end
	end
snippet class BlankSlate
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
	end
snippet class Self
alias claself
	class << ${1:self}
		${2}
	end
snippet class DelegateClass
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end
	end
snippet class Rails Model
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		include ActiveModel::Conversion
		include ActiveModel::Validations
		extend  ActiveModel::Naming

		attr_accessor :${1:attributes}

		def initialize(attributes = {})
			attributes.each do |name, value|
				send("#{name}=", value)
			end
		end

		def persisted?
			false
		end
	end
snippet class Rails 4.0 Model
alias clr
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		include ActiveModel::Model

		attr_accessor :${1:attributes}

		def initialize(attributes = {})
			attributes.each do |name, value|
				send("#{name}=", value)
			end
		end
	end
snippet class RuntimeError
	class ${1:NewExtented}Error < RuntimeError; end
snippet struct
	Struct.new(:${1:attr_name})
snippet module basic
alias mod
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
	end
snippet module module_function
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		module_function

		${2}
	end
snippet module ClassMethods
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
snippet module ActiveSupport::Concern
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		extend ActiveSupport::Concern

		included do
			${1:validates :example, presence: true}
		end

		def ${2:sample_method}
			${3:code}
		end
	end
# attr_reader
snippet attr
	attr_reader :${1:attr_names}
# attr_writer
snippet attw
	attr_writer :${1:attr_names}
# attr_accessor
snippet attrw
	attr_accessor :${1:attr_names}
snippet attp
	attr_protected :${1:attr_names}
snippet atta
	attr_accessible :${1:attr_names}
snippet accepts_nested_attributes_for
	accepts_nested_attributes_for :${1:association}
snippet const
	Object.const_get(${1:name}.capitalize)
snippet enum
	enum ${1:name}: [:${2:option_1}, :${3:other_options}]
# ivc == instance variable cache
snippet ivc
	@${1:variable_name} ||= ${2:chached_value}
# include
snippet include
	include ${1:ActiveModel::}${2:Validations}
snippet extend
	extend ${1:ActiveSupport::}${2:Memoizable}
# include Enumerable
snippet enumerable
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet comparable
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet def self.method
alias defs
	def self.${1:class_method_name}
		${2}
	end
snippet def self.[]
	def self.[](${1:attr})
		${2}
	end
# def initialize
snippet def init
alias defi init
	def initialize(${1:args})
		${2}
	end
# def method_missing
snippet def method_missing
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet def delegator
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet def delegators
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet define_method
	define_method '${1:method_name}' do
		${2:implementation}
	end
snippet define_method args
	define_method '${1:method_name}' do |*args, &block|
		${2:implementation}
		send '$1', *args, &block
	end
snippet class_eval
	${1:klass}.class_eval do
		${2:implementation}
	end
snippet instance_eval
	${1:instance}.instance_eval do
		${2:implementation}
	end
snippet alias method
	alias_method :${1:new_name}, :${2:old_name}
snippet alias attribute
	alias_attribute :${1:new_name}, :${2:old_name}
snippet __ file
alias __f
	__FILE__
snippet __ line
alias __l
	__LINE__
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort 'Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}'${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort 'Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}'${3}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet file foreach
	File.foreach(${1:'path/to/file'}) { |${2:line}| ${3} }
snippet file read
	File.read(${1:'path/to/file'})${2}
snippet file dirname
alias dir
	File.dirname(${1:__FILE__})
snippet Dir glob
	Dir.glob(${1:'dir/glob/*'}) { |${2:file}| ${3} }
snippet Dir ['..']
	Dir[${1:'glob/**/*.rb'}]${2}
snippet deli
options word
	delete_if { |${1:e}| ${2} }
snippet fill
options word
	fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
snippet flao
options word
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
options word
	zip(${1:enums}) { |${2:row}| ${3} }
# downto(0) { |n| .. }
snippet downto
options word
	downto(${1:0}) { |${2:n}| ${3} }
snippet step
options word
	step(${1:2}) { |${2:n}| ${3} }
snippet times
options word
	times { |${1:n}| ${2} }
snippet upto
options word
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet loop
options word
	loop { ${1} }
snippet each
alias ea
options word
	each { |${1:e}| ${2} }
snippet each do
alias ead
options word
	each do |${1:e}|
		${2}
	end
snippet each_byte
options word
	each_byte { |${1:byte}| ${2} }
snippet each_char
options word
	each_char { |${1:chr}| ${2} }
snippet each_cons
options word
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet each_index
alias eai
options word
	each_index { |${1:i}| ${2} }
snippet each_index do
alias eaid
options word
	each_index do |${1:i}|
		${2}
	end
snippet each_key
alias eak
options word
	each_key { |${1:key}| ${2} }
snippet each_key do
alias eakd
options word
	each_key do |${1:key}|
		${2}
	end
snippet each_line
alias eal
options word
	each_line { |${1:line}| ${2} }
snippet each_line do
alias eald
options word
	each_line do |${1:line}|
		${2}
	end
snippet each_pair
options word
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet each_pair do
options word
	each_pair do |${1:name}, ${2:val}|
		${3}
	end
snippet each_slice
options word
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet each_slice do
options word
	each_slice(${1:2}) do |${2:group}|
		${3}
	end
snippet each_value
options word
	each_value { |${1:val}| ${2} }
snippet each_value do
options word
	each_value do |${1:val}|
		${2}
	end
snippet each_with_index
alias eawi
options word
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet each_with_index do
alias eawid
options word
	each_with_index do |${1:e}, ${2:i}|
		${3}
	end
snippet eawo
options word
	each_with_object(${1:init}) { |${2:e}, ${3:var}| ${4} }
snippet eawod
options word
	each_with_object(${1:init}) do |${2:e}, ${3:var}|
		${4}
	end
snippet reve
options word
	reverse_each { |${1:e}| ${2} }
snippet reved
options word
	reverse_each do |${1:e}|
		${2}
	end
snippet inject
options word
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet inject do
options word
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end
snippet reduce
options word
	reduce(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet reduce do
options word
	reduce(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end
snippet map method
options word
	map(&:${1:id})
snippet map block
options word
	map { |${1:e}| ${2} }
snippet map do block
options word
	map do |${1:e}|
		${2}
	end
snippet mapwi-
options word
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sort
options word
	sort { |a, b| ${1} }
snippet sort_by
options word
	sort_by { |${1:e}| ${2} }
snippet ran
options word
	sort_by { rand }
snippet all
options word
	all? { |${1:e}| ${2} }
snippet any
options word
	any? { |${1:e}| ${2} }
snippet classify
options word
	classify { |${1:e}| ${2} }
snippet collect
options word
	collect { |${1:e}| ${2} }
snippet collect do
options word
	collect do |${1:e}|
		${2}
	end
snippet detect
options word
	detect { |${1:e}| ${2} }
snippet detect do
options word
	detect do |${1:e}|
		${2}
	end
snippet fetch
options word
	fetch(${1:name}) { |${2:key}| ${3} }
snippet find
options word
	find { |${1:e}| ${2} }
snippet find do
options word
	find do |${1:e}|
		${2}
	end
snippet find_all
options word
	find_all { |${1:e}| ${2} }
snippet find_all do
options word
	find_all do |${1:e}|
		${2}
	end
snippet fino
options word
	find_or_initialize_by_name(${1:attributes}) do |${1:e}|
		${2}
	end
snippet find_or_initialize_by
options word
	find_or_initialize_by(${1:attribute}: ${2:value})
snippet find_or_create_by
options word
	find_or_create_by(${1:attribute}: ${2:value})
snippet grep
options word
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
options word
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet scan
options word
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet scan do
options word
	scan(${1:/pattern/}) do |${2:match}|
		${3}
	end
snippet max
options word
	max { |a, b| ${1} }
snippet min
options word
	min { |a, b| ${1} }
snippet par
options word
	partition { |${1:e}| ${2} }
snippet pard
options word
	partition do |${1:e}|
		${2}
	end
snippet reject
options word
	reject { |${1:e}| ${2} }
snippet reject do
options word
	reject do |${1:e}|
		${2}
	end
snippet select
options word
	select { |${1:e}| ${2} }
snippet select do
options word
	select do |${1:e}|
		${2}
	end
snippet lambda
alias lam
	lambda { |${1:args}| ${2} }
snippet do empty
	do
		${1}
	end
snippet do default
alias do
	do |${1:v}|
		${2}
	end
snippet open
	open(${1:'path/or/url/or/pipe'}, '${2:w}') { |${3:io}| ${4} }
# path_from_here()
snippet file path from here
	File.join(File.dirname(__FILE__), '${1:path}')
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${3}
	end
# option_parse {}
snippet optp
	require 'optparse'

	options = {${1:default: 'args'}}

	ARGV.options do |opts|
		opts.banner = 'Usage: #{File.basename($PROGRAM_NAME)}'
snippet opt
	opts.on('-${1:o}', '--${2:long-option-name}', ${3:String},
			'${4:Option description.}') do |${5:opt}|
		${6}
	end

#############################################
# MiniTest
#############################################
snippet minitest
	gem 'minitest'
	require 'minitest/autorun'
	${1}

	class ${2:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < Minitest::Test
		${3}
	end
snippet minitest spec
	gem 'minitest'
	require 'minitest/autorun'
	${1}

	describe ${2:object} do
		${3}
	end
# Test Methods
snippet test rails
	test '${1:something}' do
		${2}
	end
snippet test def
	def test_${1:case_name}
		${2}
	end

#############################################
# Minitest Mock
#############################################
snippet mock
	${1:object} = MiniTest::Mock.new
snippet mock expect
	expect(${1:name}, ${2:val}, ${3:args = []})

#############################################
# TestCase in Rails
#############################################
snippet testcase
	require 'test_helper'

	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ActionController::TestCase
		test '${2}' do
			${3}
		end
	end
# Rails API related
snippet setup host
	setup { host! '${1:api}.example.com' }
snippet protect_from_forgery
alias forgery
	protect_from_forgery with: :null_session
snippet header
	self.headers['${1:WWW-Authenticate}'] = ${2:string}
snippet authenticate_with_http_basic
	authenticate_with_http_basic do |username, password|
		${1:User}.authenticate(username, password)
	end
snippet authenticate_with_http_token
	authenticate_with_http_token do |token, options|
		${1:User}.find_by(${2:auth_token}: token)
	end
snippet authenticate_or_request_with_http_basic
	authenticate_or_request_with_http_basic do |username, password|
		${1:User}.authenticate(username, password)
	end
snippet authenticate_or_request_with_http_token
	authenticate_or_request_with_http_token do |token, options|
		${1:User}.find_by(${2:auth_token}: token)
	end
snippet encode_credentials basic
	ActionController::HttpAuthentication::Basic.encode_credentials(${1:username}, ${2:password})
snippet encode_credentials token
	ActionController::HttpAuthentication::Token.encode_credentials(${1:token})
snippet get api
	get '${1:path}'
snippet get api format
	get '${1:path}', {}, {Accept: Mime::${2:JSON}}
snippet get api authorization
	get '${1:path}', {}, {Authorization: ${2:string}, Accept: Mime::${3:JSON}}
snippet get api language
	get '${1:path}', {}, {Accept-Language: '${2:en}', Accept: Mime::${3:JSON}}
snippet post api
	post '${1:path}',
		{ ${2:model}: { ${3:contents} } }.to_json,
		{ 'Accept' => Mime::${4:JSON}, 'Content-Type' => Mime::JSON.to_s }
snippet patch api
	patch '${1:path}',
			{ ${2:model}: { ${3:contents} } }.to_json,
			{ 'Accept' => Mime::${4:JSON}, 'Content-Type' => Mime::JSON.to_s }
snippet delete api
	delete '${1:path}'
# Responses Code
snippet status 200 ok
	:ok
snippet status 201 created
	:created
snippet status 202 accepted
	:accepted
snippet status 203 non_authoritative_information
	:non_authoritative_information
snippet status 204 no_content
	:no_content
snippet status 301 moved_permanently
	:moved_permanently
snippet status 302 found
	:found
snippet status 304 not_modified
	:not_modified
snippet status 307 temporary_redirect
	:temporary_redirect
snippet status 308 permanent_redirect
	:permanent_redirect
snippet status 400 bad_request
	:bad_request
snippet status 401 unauthorized
	:unauthorized
snippet status 403 forbidden
	:forbidden
snippet status 404 not_found
	:not_found
snippet status 405 method_not_allowed
	:method_not_allowed
snippet status 406 not_acceptable
	:not_acceptable
snippet status 415 unsupported_media_type
	:unsupported_media_type
snippet status 422 unprocessable_entity
	:unprocessable_entity
snippet status 500 internal_server_error
	:internal_server_error

#############################################
# Assertions
#############################################
snippet assert
alias as
	assert ${1:test}, '${2:Failure message.}'${3}
snippet assert_equal
alias ase
	assert_equal ${1:expected}, ${2:actual}${3}
snippet assert_not_equal
alias asne
	assert_not_equal ${1:unexpected}, ${2:actual}${3}
snippet assert_in_delta
alias asid
	assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2 ** -20}${4}
snippet assert_instance_of
alias asio
	assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}${3}
snippet assert_kind_of
alias asko
	assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}${3}
snippet assert_nil
alias asn
	assert_nil ${1:instance}${2}
snippet assert_not_nil
alias asnn
	assert_not_nil ${1:instance}${2}
snippet assert_match
alias asm
	assert_match /${1:expected_pattern}/, ${2:actual_string}${3}
snippet assert_no_match
alias asnm
	assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}${3}
snippet assert_operator
alias aso
	assert_operator ${1:left}, :${2:operator}, ${3:right}${4}
snippet assert_raise
alias asr
	assert_raise ${1:Exception} { ${2} }
snippet assert_raise do..end
alias asrd
	assert_raise ${1:Exception} do
		${2}
	end
snippet assert_nothing_raised
alias asnr
	assert_nothing_raised ${1:Exception} { ${2} }
snippet assert_nothing_raised do..end
alias asnrd
	assert_nothing_raised ${1:Exception} do
		${2}
	end
snippet assert_respond_to
alias asrt
	assert_respond_to ${1:object}, :${2:method}${3}
snippet assert_same
alias assame
	assert_same ${1:expected}, ${2:actual}${3}
snippet assert_not_same
alias asns
	assert_not_same ${1:unexpected}, ${2:actual}${3}
snippet assert_send
alias assend
	assert_send [${1:object}, :${2:message}, ${3:args}]${4}
snippet assert_throws
alias ast
	assert_throws :${1:expected} { ${2} }
snippet assert_throws do..end
alias astd
	assert_throws :${1:expected} do
		${2}
	end
snippet assert_nothing_thrown
alias asnt
	assert_nothing_thrown { ${1} }
snippet assert_nothing_thrown do..end
alias asntd
	assert_nothing_thrown do
		${1}
	end
snippet flunk
	flunk '${1:failure message}'
snippet skip
	skip '${1:skip message}'
# rails assertions
snippet assert_routing
alias ar
	assert_routing '${1:/path/}', { controller: '${2}', action: '${3}' }

#############################################
# Minitest Spec
#############################################
snippet must_be
options word
	must_be ${1}
snippet must_be_close_to
options word
	must_be_close_to ${1}
snippet must_be_empty
options word
	must_be_empty ${1}
snippet must_be_instance_of
options word
	must_be_instance_of ${1}
snippet must_be_kind_of
options word
	must_be_kind_of ${1}
snippet must_be_nil
options word
	must_be_nil ${1}
snippet must_be_same_as
options word
	must_be_same_as ${1}
snippet must_be_silent
options word
	must_be_silent ${1}
snippet must_be_within_delta
options word
	must_be_within_delta ${1}
snippet must_be_within_epsilon
options word
	must_be_within_epsilon ${1}
snippet must_equal
options word
	must_equal ${1}
snippet must_include
options word
	must_include ${1}
snippet must_match
options word
	must_match ${1}
snippet must_output
options word
	must_output ${1}
snippet must_raise
options word
	must_raise ${1}
snippet must_respond_to
options word
	must_respond_to ${1}
snippet must_send
options word
	must_send ${1}
snippet must_throw
options word
	must_throw ${1}
snippet wont_be
options word
	wont_be ${1}
snippet wont_be_close_to
options word
	wont_be_close_to ${1}
snippet wont_be_empty
options word
	wont_be_empty ${1}
snippet wont_be_instance_of
options word
	wont_be_instance_of ${1}
snippet wont_be_kind_of
options word
	wont_be_kind_of ${1}
snippet wont_be_nil
options word
	wont_be_nil ${1}
snippet wont_be_same_as
options word
	wont_be_same_as ${1}
snippet wont_be_within_delta
options word
	wont_be_within_delta ${1}
snippet wont_be_within_epsilon
options word
	wont_be_within_epsilon ${1}
snippet wont_equal
options word
	wont_equal ${1}
snippet wont_include
options word
	wont_include ${1}
snippet wont_match
options word
	wont_match ${1}
snippet wont_respond_to
options word
	wont_respond_to ${1}

#############################################
# Benchmark
#############################################
snippet benchmark measure
	puts Benchmark.measure do
		${1}
	end
snippet benchmark bm
	Benchmark.bm do |bm|
		${1}
	end
snippet benchmark bmbm
	Benchmark.bmbm do |bm|
		${1}
	end
snippet benchmark block
	bm.report('${1:name}:') do
		${2}
	end
snippet benchmark single line
	bm.report('${1:name}:') { ${2} }

# Marshal.dump(.., file)
snippet Md
	File.open(${1:'path/to/file.dump'}, 'wb') { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
snippet Ml
	File.open(${1:'path/to/file.dump'}, 'rb') { |${2:file}| Marshal.load($2) }${3}
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
snippet Pn-
	PStore.new(${1:'file_name.pstore'})${2}
snippet transaction
	transaction(${1:true}) { ${2} }
snippet transaction do
	transaction do
		${1}
	end
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:'path/to/file'}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:'//Xpath'}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split('::').inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet namespace
	namespace :${1:`vim_snippets#Filename()`} do
		${2}
	end
snippet task default
	desc '${1:description}'
	task ${2:name}: [:${3:dependent}] do
		${4}
	end
snippet task with args
	desc '${1:description}'
	task ${2:name}, [:${3:arg}] do |t, args|
		args.with_defaults($3: $4)
		${5}
	end
snippet task with args and prerequisites
	desc '${1:description}'
	task ${2:name}, [:${3:arg}] => [:${4:prereq}] do |t, args|
		args.with_defaults($3: $5)
		${6}
	end
snippet task file
	file '${1:output}' => ['${2:dependent}'] do |t|
		${3}
	end
snippet rake
	Rake::Task[:${1:task_name}].${2:invoke}
# block
snippet b
	{ |${1:var}| ${2} }
snippet begin
	begin
		raise 'A test exception.'
	rescue Exception => e
		puts e.message
		puts e.backtrace.inspect
	else
		# other exception
	ensure
		# always executed
	end
#debugging
snippet debugger byebug
alias byebug
	byebug
snippet debugger pry-remote
alias pry-remote
	require 'pry-remote'
	binding.remote_pry
snippet debugger pry
alias pry
	require 'pry'
	binding.pry

#############################################
# Sinatra snippets
#############################################
snippet sinatra
	require 'sinatra'

	${1}

#############################################
# Rails snippets
#############################################
snippet assert_redirected_to action
alias art
	assert_redirected_to ${1:action}: '${2:index}'}
snippet assert_redirected_to path
alias art
	assert_redirected_to ${1:parent}_path ${2}
snippet assert_difference
alias asd
	assert_difference '${1:Model}.${2:count}', ${3:1} do
		${4}
	end
snippet assert_no_difference
alias asnd
	assert_no_difference '${1:Model}.${2:count}' do
		${3}
	end
snippet assert_response
alias asre
	assert_response :${1:success}, @response.body${2}
snippet assert_rjs
alias asrj
	assert_rjs :${1:replace}, '${2:dom id}'
snippet assert_select
alias asselect
	assert_select '${1:path}', ${2:text}: '${3:inner_html' ${4:do}
snippet belongs_to
alias bt
	belongs_to :${1:association}
snippet belongs_to (polymorphic)
alias btp
	belongs_to :${1:association}, polymorphic: true${2}
snippet crw
	cattr_accessor :${1:attr_names}
snippet defcreate
	# POST /$1
	# POST /$1.json
	def create
		@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])

		respond_to do |format|
			if @$1.save
				format.html { redirect_to @$1, notice: '$2 was successfully created.' }
				format.json { render json: @$1, status: :created, location: @$1 }
			else
				format.html { render action: 'new' }
				format.json { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end${3}
snippet defdestroy
	# DELETE /$1/1
	# DELETE /$1/1.json
	def destroy
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
		@$1.destroy

		respond_to do |format|
			format.html { redirect_to $1s_url }
			format.json  { head :no_content }
		end
	end${3}
snippet defedit
	# GET /$1/1/edit
	def edit
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	end${3}
snippet defindex
	# GET /$1
	# GET /$1.json
	def index
		@${1:model_class_name} = ${2:ModelClassName}.all

		respond_to do |format|
			format.html # index.html.erb
			format.json { render json: @$1s }
		end
	end${3}
snippet defnew
	# GET /$1/new
	# GET /$1/new.json
	def new
		@${1:model_class_name} = ${2:ModelClassName}.new

		respond_to do |format|
			format.html # new.html.erb
			format.json { render json: @$1 }
		end
	end${3}
snippet defshow
	# GET /$1/1
	# GET /$1/1.json
	def show
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			format.html # show.html.erb
			format.json { render json: @$1 }
		end
	end${3}
snippet defupdate
	# PUT /$1/1
	# PUT /$1/1.json
	def update
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			if @$1.update_attributes(params[:$1])
				format.html { redirect_to @$1, notice: '$2 was successfully updated.' }
				format.json { head :no_content }
			else
				format.html { render action: 'edit' }
				format.json { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end${3}
snippet delegate to
	delegate :${1:methods}, to: :${2:object}
snippet delegate to prefix
	delegate :${1:methods}, to: :${2:object}, prefix: ${3:true}
snippet delegate to allow_nil
	delegate :${1:methods}, to: :${2:object}, allow_nil: ${3:true}
snippet flash
	flash[:${1:notice}] = '${2}'
snippet content_tag
	content_tag :${1:div}, ${2:content}, ${3:options}
snippet content_tag do
	content_tag :${1:div}, ${2:options} do
		${3:content}
	end
snippet hasabtm
	has_and_belongs_to_many :${1:object}, join_table: '${2:table_name}', foreign_key: '${3}_id'${4}
snippet hasm
	has_many :${1:object}
snippet hasmd
	has_many :${1:other}s, class_name: '${2:$1}', foreign_key: '${3:$1}_id', dependent: :destroy${4}
snippet hasmt
	has_many :${1:object}, through: :${2:object}
snippet haso
	has_one :${1:object}
snippet hasod
	has_one :${1:object}, dependent: :${2:destroy}
snippet i18 translate
alias i18t
	I18n.t('${1:type.key}')${2}
snippet i18 translate shorthand
alias t
	t('${1:type.key}')
snippet i18 localize
alias i18l
	I18n.l('${1:type.key}')${2}
snippet i18 localize shorthand
alias l
	l('${1:type.key}')${2}
snippet log
	${1:Rails.logger}.${2:debug} ${3}
snippet logd
	logger.debug { '${1:message}' }${2}
snippet loge
	logger.error { '${1:message}' }${2}
snippet logf
	logger.fatal { '${1:message}' }${2}
snippet logi
	logger.info { '${1:message}' }${2}
snippet logw
	logger.warn { '${1:message}' }${2}
snippet mapc
	${1:map}.${2:connect} '${3:controller/:action/:id}'
snippet mapca
	${1:map}.catch_all '*${2:anything}', controller: '${3:default}', action: '${4:error}'${5}
snippet mapr
	${1:map}.resource :${2:resource}
snippet maprs
	${1:map}.resources :${2:resource}
snippet mapwo
	${1:map}.with_options ${2:controller}: '${3:thing}' do |$3|
		${4}
	end
snippet mbs before_save
	before_save :${1:method}
snippet mcht
	change_table :${1:table_name} do |t|
		${2}
	end
snippet mrw
	mattr_accessor :${1:attr_names}
snippet order field
	order('${1:field}')
snippet order 4.0 field
	order(:${1:field})
snippet order field desc
	order('${1:field} DESC')
snippet order 4.0 field desc
	order(${1:field}: :desc)
snippet params
	params[:${1:id}]${2}
snippet params strong
	params.require(:${1:model}).permit(:${2:fields})
snippet params def
	def ${1:model}_params
		params.require(:$1).permit(:${2:fields})
	end
snippet respond_to
	respond_to :${1:json}
snippet respond_to do
	respond_to do |format|
		format.${1:html} { ${2} }
		format.${3:json} { render json: ${4:json_data}, status: :ok }
	end
snippet render action
alias ra
	render action: '${1:action}'
snippet render action layout
alias ral
	render action: '${1:action}', layout: '${2:layoutname}'
snippet render file
alias rf
	render file: '${1:filepath}'
snippet render file full_path
alias rfu
	render file: '${1:filepath}', use_full_path: ${2:false}
snippet render inline
alias ri
	render inline: '${1:<%= 'hello' %>}'
snippet render inline locals
alias ril
	render inline: '${1:<%= 'hello' %>}', locals: { ${2::name}: '${3:value}'${4} }
snippet render inline type
alias rit
	render inline: '${1:<%= 'hello' %>}', type: ${2::rxml}
snippet render xml
alias rxml
	render xml: ${1:text to render}
snippet render json
alias rjson
	render json: ${1:text to render}
snippet render layout
alias rl
	render layout: '${1:layoutname}'
snippet render nothing
alias rn
	render nothing: ${1:true}
snippet render nothing status
alias rns
	render nothing: ${1:true}, status: ${2:401}
snippet render partial
alias rp
	render partial: '${1:item}'
snippet render partial collection
alias rpc
	render partial: '${1:item}', collection: ${2:@$1s}
snippet render partial locals
alias rpl
	render partial: '${1:item}', locals: { ${2:$1}: ${3:@$1} }
snippet render partial object
alias rpo
	render partial: '${1:item}', object: ${2:@$1}
snippet render partial status
alias rps
	render partial: '${1:item}', status: ${2:500}
snippet render text
alias rt
	render text: '${1:text to render}'
snippet render text layout
alias rtl
	render text: '${1:text to render}', layout: '${2:layoutname}'
snippet render text status
alias rts
	render text: '${1:text to render}', status: ${2:401}
snippet render update do
alias ru
	render :update do |${1:page}|
		$1.${2}
	end
snippet scope default
alias defscope
	default_scope -> { ${1:scope} }
snippet scope ->
	scope :${1:name}, -> { ${2:scope} }
snippet scope lambda
	scope :${1:name}, lambda do |${2:value}|
		${3:scope}
	end
snippet sha1
	Digest::SHA1.hexdigest(${1:string})
snippet base64
	require 'base64'
	Base64.encode64(${1:string})
snippet cache fetch
	Rails.cache.fetch([${1:self}, '${2:method}']) { ${3:block} }
snippet cache fetch do
	Rails.cache.fetch([${1:self}, '${2:method}']) do
		${3:block}
	end
snippet cache fetch expires_in
	Rails.cache.fetch([${1:self}, '${2:method}'], expires_in: ${3:30.minutes}) do
		${3:block}
	end
snippet cache read
	Rails.cache.read(${1:key})
snippet cache write
	Rails.cache.write(${1:key}, ${2:value})
snippet cache delete
	Rails.cache.delete(${1:key})
snippet cache clear
	Rails.cache.clear
snippet sweeper
	class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper
		observe $1

		def after_save(${2:model_class_name})
			expire_cache($2)
		end

		def after_destroy($2)
			expire_cache($2)
		end

		def expire_cache($2)
			expire_page
		end
	end
snippet validator
	class ${1:What}Validator < ActiveRecord::${2:Each}Validator
		def validate_each(record, attribute, value)
			${3}
		end
	end
snippet validate
	validate :${1:method}
snippet validates
	validates :${1:attribute}, ${2:validators}
snippet validates acceptance
alias valac
	validates :${1:terms}, acceptance: true
snippet validates confirmation
alias valc
	validates :${1:attribute}, confirmation: true
snippet validates exclusion
alias vale
	validates :${1:attribute}, exclusion: { in: ${2:%w( mov avi )} }
snippet validates format
alias valf
	validates :${1:attribute}, format: { with: /${2:regex}/ }
snippet validates inclusion
alias vali
	validates :${1:attribute}, inclusion: { in: %w(${2: mov avi }) }
snippet validates length
alias vall
	validates :${1:attribute}, length: { in: ${2:3}..${3:20} }
snippet validates numericality
alias valn
	validates :${1:attribute}, numericality: ${1:true}
snippet validates presence
alias valp
	validates :${1:attribute}, presence: true
snippet validates uniqueness
alias valu
	validates :${1:attribute}, uniqueness: true
snippet validates_associated
alias valas
	validates_associated :${1:attribute}
snippet validates_with
alias valw
	validates_with ${1:Some}Validator
snippet format
	format.${1:js|xml|html} { ${2} }
snippet where field:value
	where(${1:field}: ${2:value})
snippet where condition
	where(${1:'conditions'}${2:, bind_var})
snippet add_flash_types
	add_flash_types :${1:warning}
snippet xdelete
	xhr :delete, :${1:destroy}, id: ${2:1}${3}
snippet xget
	xhr :get, :${1:show}, id: ${2:1}${3}
snippet xpost
	xhr :post, :${1:create}, ${2:object}: { ${3} }
snippet xput
	xhr :put, :${1:update}, id: ${2:1}, ${3:object}: { ${4} }${5}
# before, around, after
snippet before validation
	before_validation ${1}
snippet after validation
	after_validation ${1}
snippet before save
	before_save ${1}
snippet after save
	after_save ${1}
snippet before create
	before_create ${1}
snippet around create
	around_create ${1}
snippet after create
	after_create ${1}
snippet before update
	before_update ${1}
snippet around update
	around_update ${1}
snippet after update
	after_update ${1}
snippet before destroy
	before_destroy ${1}
snippet after destroy
	after_destroy ${1}
snippet around destroy
	around_destroy ${1}
# filter
snippet before skip filter
	skip_before_filter :${1:method}
snippet before filter
	before_filter :${1:method}
snippet before action
	before_action :${1:method}
snippet only
	only: [${1:methods}]
snippet except
	except: [${1:methods}]
snippet to_param
	def to_param
		"#{id}-#{${1:name}.parameterize}"
	end
snippet method missing
	def method_missing(method_name, *args, &block)
		@${1:instance}.send(method_name, *args, &block)
		super
	end
snippet respond respond_to_missing?
	def respond_to_missing?(method_name, *args, &block)
		@${1:instance}.respond_to?(method_name, *args, &block)
	end

###########################
#   route snippets        #
###########################
snippet root to
	root to: '${1:home#index}'
snippet post to
	post '${1:path}', to: '${2:controller}#${3:action}'
snippet get to
	get '${1:path}', to: '${2:controller}#${3:action}'
snippet patch to
	patch '${1:path}', to: '${2:controller}#${3:action}'
snippet resources
	resources :${1:model}
snippet resources controller
	resources :${1:model}, controller: '${2:demo/controllers}'
snippet resources only
	resources :${1:model}, only: [:${2:methods}]
snippet resources except
	resources :${1:model}, except: [:${2:methods}]
snippet resources constraints
	resources :${1:model}, constraints: { subdomain: '${2:api}' }
snippet resources constraints block
	constraints subdomain: '${1:api}' do
		namespace :${2:v1} do
			${3:resources} :${4:model}
		end
	end
snippet resources constraints api
	namespace :${1::v1}, constraints: { subdomain: '$1' } do
		resources ${2:model}
	end
snippet resources with options
	with_options only: [:${1:index}] do |list|
		list.${2:resources} :${3:model}
	end
snippet concern
	concern :${1:concernable} do |options|
		resources :${2:model}, options
	end

###########################
#   migrations snippets   #
###########################
snippet mac
	add_column :${1:table_name}, :${2:column_name}, :${3:data_type}
snippet mai
	add_index :${1:table_name}, :${2:column_name}
snippet mrc
	remove_column :${1:table_name}, :${2:column_name}
snippet mrnc
	rename_column :${1:table_name}, :${2:old_column_name}, :${3:new_column_name}
snippet mcc
	change_column :${1:table}, :${2:column}, :${3:type}
snippet mnc
	t.${1:string} :${2:title}${3:, null: false}${4}
snippet mct
	create_table :${1:table_name} do |t|
		${2}
	end
snippet migration class .. < ActiveRecord::Migration .. def up .. def down .. end
	class ${1:class_name} < ActiveRecord::Migration
		def up
			${2}
		end

		def down
		end
	end
snippet migration class .. < ActiveRecord::Migration .. def change .. end
	class ${1:class_name} < ActiveRecord::Migration
		def change
			${2}
		end
	end
snippet trc
	t.remove :${1:column}
snippet tre
	t.rename :${1:old_column_name}, :${2:new_column_name}
	${3}
snippet tref
	t.references :${1:model}
snippet tcb
	t.boolean :${1:title}
	${2}
snippet tcbi
	t.binary :${1:title}, :limit => ${2:2}.megabytes
	${3}
snippet tcd
	t.decimal :${1:title}, :precision => ${2:10}, :scale => ${3:2}
	${4}
snippet tcda
	t.date :${1:title}
	${2}
snippet tcdt
	t.datetime :${1:title}
	${2}
snippet tcf
	t.float :${1:title}
	${2}
snippet tch
	t.change :${1:name}, :${2:string}, :${3:limit} => ${4:80}
	${5}
snippet tci
	t.integer :${1:title}
	${2}
snippet tcl
	t.integer :lock_version, :null => false, :default => 0
	${1}
snippet tcr
	t.references :${1:taggable}, polymorphic: { default: '${2:Photo}' }
	${3}
snippet tcs
	t.string :${1:title}
	${2}
snippet tct
	t.text :${1:title}
	${2}
snippet tcti
	t.time :${1:title}
	${2}
snippet tcts
	t.timestamp :${1:title}
	${2}
snippet tctss
	t.timestamps
	${1}

##########################
#     Rspec snippets     #
##########################
snippet rspec unit
	require 'spec_helper'

	describe '${1:a behaviour}' do
		${2:pending 'Not implemented'}
	end
snippet rspec feature
	require 'spec_helper'

	feature '${1:an action}' do
		${2:pending 'Not implemented'}
	end
snippet rspec rails
	require 'rails_helper'

	RSpec.describe '${1}', type: :${2} do
		${3}
	end
snippet describe
alias desc
	describe ${1:name} do
		${2:pending 'Not implemented'}
	end
snippet context
	context '${1:message}' do
		${2}
	end
snippet it block
alias it
	it '${1:spec_name}' do
		${2}
	end
snippet specify
	specify { subject.${1} }
snippet before rspec
alias bef
	before :${1:each} do
		${2}
	end
snippet after rspec
alias aft
	after :${1:each} do
		${2}
	end
snippet let
	let(:${1:object}) { ${2} }
snippet let!
	let!(:${1:object}) { ${2} }
snippet subject {}
alias subj
	subject { ${1} }
snippet subject object
	subject(:${1:instance}) { ${2} }
snippet shared_examples
	shared_examples '${1:shared examples name}' do
		it '${2:does something}' do
			${3}
		end
	end
snippet it_behaves_like
alias ibl
	it_behaves_like '${1:shared examples name}'

##########################
# RSpec Expects
##########################
snippet expect general
alias ex
	expect(${1:target}).to ${2}
# equal
snippet expect eq
alias ee
	expect(${1:target}).to eq(${2})
snippet expect not eq
alias ene
	expect(${1:target}).not_to eq(${2})
snippet expect eql
	expect(${1:target}).to eql(${2})
snippet expect not eql
	expect(${1:target}).not_to eql(${2})
snippet expect equal
	expect(${1:target}).to equal(${2})
snippet expect not equal
	expect(${1:target}).not_to equal(${2})
# be
snippet expect be
	expect(${1:target}).to be ${2}
snippet expect not be
	expect(${1:target}).not_to be ${2}
snippet expect be_true
alias ebt
	expect(${1:target}).to be_true
snippet expect be_false
alias ebf
	expect(${1:target}).to be_false
snippet expect be_nil
alias ebn
	expect(${1:target}).to be_nil
snippet expect be_within
alias ebw
	expect(${1:target}).to be_within(${2:0.1}).of(${3:1.9})
snippet expect be_a/an
	expect(${1:target}).to be_a(${2:type})
snippet expect be_instance
	expect(${1:target}).to be_an_instance_of(${2:type})
# exists
snippet expect exist
	expect(${1:target}).to exist
# range change
snippet expect change from to
alias ecft
	expect { ${1:action} }.to change { ${2:target} }.from(${3:0}).to(${4:1})
snippet expect change by
alias ecb
	expect { ${1:action} }.to change { ${2:target} }.by(${3:1})
# exception/error
snippet expect raise error
alias ere
	expect { ${1:action} }.to raise_error(${2})
# match
snippet expect match
alias em
	expect(${1:target}).to match(${2})
# response to
snippet expect response to
alias ert
	expect(${1:target}).to respond_to(:${2:method})
# satisfy
snippet expect satisfy
alias es
	expect(${1:target}).to satisfy { |${2:arg}| ${3} }
# mock and stub
snippet allow receive.and_return
	allow(${1:mock}).to receive(:${2:method}).and_return(${3:result})
snippet allow receive {}
	allow(${1:mock}).to receive(:${2:method}) { ${3:result} }
snippet allow receive_message_chain
	allow(${1:mock}).to receive_message_chain(:${2:method1}, :${3:method2})
snippet allow any_instance
	allow_any_instance_of(${1:Class}).to receive(:${2:method}) { ${3:result} }
# instance.stub
snippet stub
options word
	stub(${1:method}: ${2:return})
snippet stub returns
options word
	stub(:${1:method}).and_return(${3:return_value})
snippet stub chain
options word
	stub_chain(:${1:one}, :${2:two}).and_return(${3:return_value})
snippet stub instance
alias any_instance
options word
	any_instance.stub(:${1:method}).and_return(${2:return_value})
# instance.should_receive
snippet should_receive
options word
	should_receive(:${1:message}).and_return(:${2:return_value})
snippet should_receive args
options word
	should_receive(:${1:message}).with(${2:args})
snippet should_receive anything
options word
	should_receive(:${1:message}).with(anything())
snippet should_receive once
options word
	should_receive(:${1:message}).once
snippet should_receive twice
options word
	should_receive(:${1:message}).twice
snippet should_receive exactly times
options word
	should_receive(:${1:message}).exactly(${2:n}).times
snippet should_receive at_least once
options word
	should_receive(:${1:message}).at_least(:once)
snippet should_receive at_least twice
options word
	should_receive(:${1:message}).at_least(:twice)
snippet should_receive at_least times
options word
	should_receive(:${1:message}).at_least(${2:n}).times
snippet should_receive at_most once
options word
	should_receive(:${1:message}).at_most(:once)
snippet should_receive at_most twice
options word
	should_receive(:${1:message}).at_most(:twice)
snippet should_receive at_most times
options word
	should_receive(:${1:message}).at_most(${2:n}).times
snippet should_receive any_number_of_times
options word
	should_receive(:${1:message}).any_number_of_times
# it is expected shorthands
snippet it match
	it { is_expected.to match(${1}) }
snippet it allow_mass_assignment_of
	it { is_expected.to allow_mass_assignment_of(${1}) }
snippet it allow_value
	it { is_expected.to allow_value(${1}) }
snippet it validate_inclusion_of
	it { is_expected.to validate_inclusion_of(${1}) }
snippet it validate_exclusion_of
	it { is_expected.to validate_exclusion_of(${1}) }
snippet it ensure_length_of
	it { is_expected.to ensure_length_of(${1}) }
snippet it have_secure_password
	it { is_expected.to have_secure_password(${1}) }
snippet it validate_confirmation_of
	it { is_expected.to validate_confirmation_of(${1}) }
snippet it validate_numericality_of
	it { is_expected.to validate_numericality_of(${1}) }
snippet it validate_presence_of
	it { is_expected.to validate_presence_of(${1}) }
snippet it validate_uniqueness_of
	it { is_expected.to validate_uniqueness_of(${1}) }
snippet it accept_nested_attributes_for
	it { is_expected.to accept_nested_attributes_for(${1}) }
snippet it belong_to
	it { is_expected.to belong_to(${1}) }
snippet it define_enum_for
	it { is_expected.to define_enum_for(${1}) }
snippet it have_many
	it { is_expected.to have_many(${1}) }
snippet it have_one
	it { is_expected.to have_one(${1}) }
snippet it have_and_belong_to_many
	it { is_expected.to have_and_belong_to_many(${1}) }
snippet it have_db_column
	it { is_expected.to have_db_column(${1}) }
snippet it have_db_index
	it { is_expected.to have_db_index(${1}) }
snippet it have_readonly_attribute
	it { is_expected.to have_readonly_attribute(${1}) }
snippet it serialize
	it { is_expected.to serialize(${1}) }
snippet it filter_param
	it { is_expected.to filter_param(${1}) }
snippet it redirect_to
	it { is_expected.to redirect_to(${1}) }
snippet it render_template
	it { is_expected.to render_template(${1}) }
snippet it render_with_layout
	it { is_expected.to render_with_layout(${1}) }
snippet it rescue_from
	it { is_expected.to rescue_from(${1}) }
snippet it respond_with
	it { is_expected.to respond_with(${1}) }
snippet it respond_with_content_type
	it { is_expected.to respond_with_content_type(${1::json}) }
snippet it route
	it { is_expected.to route(${1}) }
snippet it set_session
	it { is_expected.to set_session(${1}) }
snippet it set_the_flash
	it { is_expected.to set_the_flash(${1}) }
snippet it delegate_method
	it { is_expected.to delegate_method(${1}) }
# expect spies/doubles
snippet expect have_received
	expect(${1:instance}).to have_received(:${2:method})
snippet expect have_received
	expect(${1:instance}).to have_received(:${2:method}).with(${3:args})
snippet expect any_instance_of receive
	expect_any_instance_of(${1:Object}).to receive(:${2:method})
snippet expect receive once
	expect(${1:obj}).to receive(:${2:method}).once
snippet expect receive twice
	expect(${1:obj}).to receive(:${2:method}).twice
snippet expect receive times
	expect(${1:obj}).to receive(:${2:method}).exactly(${3:3}).times
snippet expect receive at_least times
	expect(${1:obj}).to receive(:${2:method}).at_least(${3:3}).times
snippet expect receive at_most times
	expect(${1:obj}).to receive(:${2:method}).at_most(${3:3}).times
snippet expect receive any_number_of_times
	expect(${1:obj}).to receive(:${2:method}).any_number_of_times
snippet expect receive with
	expect(${1:obj}).to receive(:${2:method}).with(${3:args})
snippet expect receive with regex
	expect(${1:obj}).to receive(:${2:method}).with(/${3:regex}/)
snippet expect receive with instance_of
	expect(${1:obj}).to receive(:${2:method}).with(an_instance_of(${3:Object}))
snippet expect receive with hash
	expect(${1:obj}).to receive(:${2:method}).with(hash_including(${3:key: val}))
snippet expect receive with anything
	expect(${1:obj}).to receive(:${2:method}).with(anything())
snippet expect receive and raise
	expect(${1:obj}).to receive(:${2:method}).and_raise('${3:an error}')
# rspec rails
snippet expect be_a_new
	expect(${1:obj}).to be_a_new(${2:Object})
snippet expect render template
	expect(${1:response}).to render_template(${2:'new'})
snippet expect render partial template
	expect(${1:response}).to render_template(partial: ${2:'_form'}, locals: { ${3} })
snippet expect redirect_to
	expect(${1:response}).to redirect_to(${2:path})
snippet expect response_with
	expect(${1:response.status}).to eq(${2:200})
snippet expect have_http_status
	expect(${1:response}).to have_http_status(${2:200})

##########################
# RSpect Should
##########################
snippet its method should
	its(:${1:method}) { should ${2} }
snippet it should
alias itsh
	it { should ${1} }
snippet it should_not
alias itsn
	it { should_not ${1} }
#ShouldaMatchers#ActionController
snippet it should filter_param
	it { should filter_param :${1:key} }
snippet it should redirect_to
	it { should redirect_to ${1:url} }
snippet it should render_template
	it { should render_template ${1} }
snippet it should render_with_layout
	it { should render_with_layout ${1} }
snippet it should rescue_from
	it { should rescue_from ${1:exception} }
snippet it should respond_with
	it { should respond_with ${1:status} }
snippet it should rout
	it { should route(:${1:method}, '${2:path}') }
snippet it should set_session
	it { should set_session :${1:key} }
snippet it should set_the_flash
	it { should set_the_flash('${1}') }
#ShouldaMatchers#ActiveModel
snippet it should allow_mass_assignment_of
	it { should allow_mass_assignment_of :${1} }
snippet it should allow_value
	it { should allow_value(${1}).for :${2} }
snippet it should ensure_exclusion_of
	it { should ensure_exclusion_of :${1} }
snippet it should ensure_inclusion_of
	it { should ensure_inclusion_of :${1} }
snippet it should ensure_length_of
	it { should ensure_length_of(:${1}).is_at_least(${2}).is_at_most(${3}) }
snippet it should validate_acceptance_of
	it { should validate_acceptance_of :${1} }
snippet it should validate_confirmation_of
	it { should validate_confirmation_of :${1} }
snippet it should validate_numericality_of
	it { should validate_numericality_of :${1} }
snippet it should validate_presence_of
	it { should validate_presence_of :${1} }
snippet it should validate_uniqueness_of
	it { should validate_uniqueness_of :${1} }
#ShouldaMatchers#ActiveRecord
snippet it should accept_nested_attributes_for
	it { should accept_nested_attributes_for :${1} }
snippet it should belong_to
	it { should belong_to :${1} }
snippet it should belong_to counter
	it { should belong_to(:${1}).counter_cache ${2:true} }
snippet it should have_and_belong_to_many
	it { should have_and_belong_to_many :${1} }
snippet it should be_valid
	it { should be_valid }${1}
snippet it should have_db_column
	it { should have_db_column :${1} }
snippet it should have_db_index
	it { should have_db_index :${1} }
snippet it should have_many
	it { should have_many :${1} }
snippet it should have_many through
	it { should have_many(:${1}).through :${2} }
snippet it should have_one
	it { should have_one :${1} }
snippet it should have_readonly_attribute
	it { should have_readonly_attribute :${1} }
snippet it should serialize
	it { should serialize :${1} }
snippet it should respond_to
	it { should respond_to :${1} }
snippet it should respond_t
	it { should respond_to(:${1}).with(${2}).arguments }
snippet super_call
	${1:super_class}.instance_method(:${2:method}).bind(self).call

#############################################
# TomDoc
#############################################
snippet doc method
	# ${1:Public/Internal/Deprecated}: ${2:what does it do?}
	#
	# ${3:args - Description}
	#
	# Examples
	#
	# ${4:bar()}
	#
	# ${5:Returns nothing.}
snippet doc class/module
	# ${1:Public/Internal/Deprecated}: ${2:what does it do?}
	#
	# Examples
	#
	# ${3:bar()}
snippet doc constant
	# ${1:Public/Internal/Deprecated}: [${2:Type}] ${3:its purpose}
snippet doca argument
	${1:arg} - ${2:description}
snippet doca argument with default
	${1:arg} - ${2:description}(default: ${3})
snippet docr returns
	Returns ${1}

# regex
snippet regex named group
alias ng
	(?<${1:name}>${2:regex})
snippet regex across line
alias rgx %r
	%r{
		${1}
	}x
snippet regex positive lookahead
alias pla
	(?=${1})
snippet regex negative lookahead
alias nla
	(?!${1})
snippet regex positive lookbehind
alias plb
	(?<=${1})
snippet regex negative lookbehind
alias nlb
	(?<!${1})

# to_json
snippet json only
	${1:instance}.to_json(include: ${2}, only: ${3})${4}
snippet json except
	${1:instance}.to_json(include: ${2}, except: ${3})${4}

# Here Document
snippet heredoc
	<<-${1:EOS}
		${2}
	$1
snippet heredoc strip
	<<-${1:END}.strip_heredoc
		${2}
	$1
snippet sql
	<<-SQL
		${1}
	SQL
snippet eof
	<<-EOF
		${1}
	EOF

#############################################
# capybara cheatsheet
#############################################
snippet feature
alias fea
	feature '${1:an action}' do
		${2:pending 'Not implemented'}
	end
snippet background
alias bg
	background do
		${1}
	end
snippet scenario
alias sce
	scenario '${1:use case}' do
		${2}
	end
snippet scenario js:true
	scenario '${1:use case}', js: true do
		${2}
	end
snippet expect have_content
alias hc
	expect(page).to have_content(${1})
snippet expect current_path
	expect(current_path).to eq(${1})
snippet expect has_selector
	expect(page).to have_selector(${1})
snippet expect has_xpath
	expect(page).to have_xpath(${1})
snippet expect has_css
	expect(page).to have_css(${1})
snippet expect checked
	expect(find('${1:selector}').checked?).to be_true
snippet visit
alias vi
	visit ${1:path}
snippet click link
alias cll
	click_link ${1:id/text}
snippet click button
alias clb
	click_button ${1:id/text}
snippet click on
alias clo
	click_on ${1:id/text}
snippet fill in
	fill_in '${1:field}', with: ${2:value}
snippet choose radio button
	choose '${1:a radio button}'
snippet check checkbox
	check '${1:a checkbox}'
snippet uncheck checkbox
	uncheck '${1:a checkbox}'
snippet select dropdown
	select '${1:option}', from: '${2:field}'
snippet unselect dropdown
	unselect '${1:option}', from: '${2:field}'
snippet attach file
	attach_file '${1:field}', '${2:path_to_file}'
snippet find default
	find('${1:selector}').${2:action}
snippet find click on
	find('${1:selector}').click_on('${2:link}')
snippet find field
	find_field('${1:selector}').${2:action}
snippet find link
	find_link('${1:text}').${2:action}
snippet find button
	find_button('${1:text}').${2:action}
snippet within
	within '${1:selector}' do
		${2}
	end

#############################################
# FactoryGirl
#############################################
snippet factory define
alias fgd
	FactoryGirl.define do
		factory :${1:name} do
			${2:attr} ${3:value}
		end
	end
snippet factory default
alias fgdf
	factory :${1:name} do
		${2:attr} ${3:value}
	end
snippet factory class
alias fgc
	factory :${1:name}, class: ${2:Model} do
		${3:attr} ${4:value}
	end
snippet factory trait
	factory :${1}, traits: [:${2:trait}]
snippet factory has_many
	factory :${1:model}_with_${2:many}s do
		ignore do
			$2s_count 5
		end

		after(:create) do |$1, evaluator|
			create_list(:$2, evaluator.$2s_count, $1: $1)
		end
	end
snippet sequence
alias seq
	sequence(:${1:field}) { |i| ${2:value} }
snippet attributes for
alias atf
	attributes_for(:${1:name})
snippet association
alias ass
	association :${1:attr}, factory: :${2:model}
snippet build
alias strategy
	strategy: :build
snippet trait
	trait :${1:name} do
		${2}
	end
snippet create_list
	create_list(:${1:of_model}, ${2:count}, ${3:to_model}: $3)
snippet build_list
	build_list(:${1:of_model}, ${2:count}, ${3:to_model}: $3)

#############################################
# cancan gem
#############################################
snippet can manage
	can? :manage, ${1:Model}
snippet can read
	can? :read, ${1:Model}
snippet can create
	can? :create, ${1:Model}
snippet can update
	can? :update, ${1:Model}
snippet can destroy
	can? :destroy, ${1:Model}
snippet can customize
	can? :${1:view}, ${2:Model}

#############################################
# pundit gem
#############################################
snippet policy
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ApplicationPolicy
		${2}
	end
snippet policy application
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		attr_reader :user, :${2:record}

		def initialize(user, $2)
			@user = user
			@$2 = $2
		end

		${3}
	end
