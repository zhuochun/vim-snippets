# Node
snippet require
alias req
	$1 = require "./${1:module}"
# Export
snippet exports
alias exp
	module.exports = ${1}
# Asset Pipeline
snippet require asset pipeline
	#= require ${1:file}
# String Interpolation
snippet #
	#{ ${1} }
# For loop
# Array comprehension
snippet for array
alias for
	for ${1:name} in ${2:array}
snippet for array comprehension
	for ${1:name}, ${2:idx} in ${2:array}
		${3:# body...}
snippet for object
alias foro
	for ${1:key}, ${2:value} in ${3:objects}
# Object comprehension
snippet for object comprehension
	for ${1:key}, ${2:value} of ${3:object}
		${4:# body...}
# Range comprehension (inclusive)
snippet for range comprehension (inclusive)
	for ${1:name} in [${2:start}..${3:finish}]
		${4:# body...}
snippet for range by comprehension (inclusive)
	for ${1:name} in [${2:start}..${3:finish}] by ${4:step}
		${5:# body...}
# Range comprehension (exclusive)
snippet for range comprehension (exclusive)
	for ${1:name} in [${2:start}...${3:finish}]
		${4:# body...}
snippet for range by comprehension (exclusive)
	for ${1:name} in [${2:start}...${3:finish}] by ${4:step}
		${5:# body...}
# Object
snippet obj
	${1:object} =
		${2:key}: ${3:value}
snippet :
	${2:key}: ${3:value}
# Slice and Splicing
snippet [ inclusive
	[${1}..${2}]
snippet [ exclusive
	[${1}...${2}]
# Function
snippet fun with params
alias ->
	(${1:args}) ->
		${2:# body...}
snippet fun without params
	-> ${1:# body...}
# Function (bound)
snippet fun bound with params
alias =>
	(${1:args}) =>
		${2:# body...}
snippet fun bound without params
	=> ${1:# body...}
# Class
snippet class
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
snippet class constructor
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		constructor: (${2:@args}) ->
			${3}

		${4}
snippet class extends
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		${3}
snippet class extends constructor
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		constructor: (${3:@args}) ->
			${4}

		${5}
snippet constructor
	constructor: (${1:@args}) ->
		${2}
snippet prototype
	${1:class}::${2:method} = ${3}
snippet ::
	${1:class}::${2:method} = ${3}
# If
snippet if
	if ${1:condition}
		${2:# body...}
snippet else
	else ${1:condition}
		${2:# body...}
# If __ Else
snippet if else
alias ife
	if ${1:condition}
		${2:# body...}
	else
		${3:# body...}
# Else if
snippet elseif
	else if ${1:condition}
		${2:# body...}
# Ternary If
snippet ifthen
alias ?
	if ${1:condition} then ${2:value} else ${3:other}
# Unless
snippet unless
	${1:action} unless ${2:condition}
# Switch
snippet switch
alias swi
	switch ${1:object}
		when ${2:value}
			${3:# body...}
		else ${0}
snippet when
	when ${1:value}
		${2:# body...}
snippet when then
	when ${1:value} then ${2:# body...}
# Console
snippet console.log
alias cl clg
	console.log ${1}
snippet console.error
alias ce cerr
	console.error ${1}
snippet console.assert
	console.assert ${1}
snippet console.trace
	console.trace ${1}
snippet console.dir
	console.dir ${1}
snippet console.timeStamp
	console.timeStamp ${1:annotation}
# Helpers
snippet array slice
alias toArray
    Array.prototype.slice.call(${1:array-like-object})
# object
snippet object keys
alias keys
	Object.keys(${1:obj})${2}
snippet object type
alias type
	Object.prototype.toString.call(${1}) == "[object ${2:Object}]"
# es6
snippet find
options head
	find((${1:i}) -> ${2})
snippet findIndex
alias index
options head
	findIndex((${1:i}) -> ${2})
snippet map
alias collect
options head
	map((${1:i}) -> ${2})
snippet filter
alias select
options head
	filter((${1:i}) -> ${2})
snippet reduce
alias inject
options head
	reduce (${1}, ${2:val}) ->
		${4}
	, ${3}
snippet forEach
alias each
options head
	forEach (${1:elem}, ${2:idx}) ->
		${3}
# Try __ Catch
snippet try
	try
		${1}
	catch ${2:error}
		${3}
# BDD Testings
snippet describe
alias des
	describe "${1:context to test}", ->
		${2}
snippet it
	it "${1:should do something}", ->
		${2}
snippet it async
	it "${1:should do something}", (done) ->
		${2:done()}
snippet before
	before ${1:(done) }->
		${2}
snippet after
	after ${1:(done) }->
		${2}
snippet beforeEach
	beforeEach ${1:(done) }->
		${2}
snippet afterEach
	afterEach ${1:(done) }->
		${2}
# Chai - Assert
snippet chai require assert
	assert = require("chai").assert${1:,}
snippet assert
	assert(${1:expression})
snippet assert equal
	assert.equal(${1:actual}, ${2:expected})
snippet assert not equal
	assert.notEqual(${1:actual}, ${2:expected})
snippet assert strict equal
	assert.strictEqual(${1:actual}, ${2:expected})
snippet assert not strict equal
	assert.notStrictEqual(${1:actual}, ${2:expected})
snippet assert deep equal
	assert.deepEqual(${1:actual}, ${2:expected})
snippet assert not deep equal
	assert.notDeepEqual(${1:actual}, ${2:expected})
snippet assert isTrue
	assert.isTrue(${1:value})
snippet assert isFalse
	assert.isFalse(${1:value})
snippet assert isNull
	assert.isNull(${1:value})
snippet assert isUndefined
	assert.isUndefined(${1:value})
snippet assert isDefined
	assert.isDefined(${1:value})
snippet assert isFunction
	assert.isFunction(${1:value})
snippet assert isObject
	assert.isObject(${1:value})
snippet assert isArray
	assert.isArray(${1:value})
snippet assert isString
	assert.isString(${1:value})
snippet assert isNumber
	assert.isNumber(${1:value})
snippet assert typeOf
	assert.typeOf(${1:value}, ${2:name})
snippet assert match
	assert.match(${1:value}, ${2:regex})
snippet assert lengthOf
	assert.lengthOf(${1:object}, ${2:length})
# Chai - Expect
snippet chai require expect
	expect = require("chai").expect${1:,}
snippet expto
	expect(${1:expression}).to.${2:equal}(${3})
snippet expto equal
	expect(${1:expression}).to.equal(${2})
snippet expto not equal
	expect(${1:expression}).to.not.equal(${2})
snippet expto deep equal
	expect(${1:expression}).to.deep.equal(${2})
snippet expto eql
	expect(${1:expression}).to.eql(${2})
snippet expto be a
	expect(${1:expression}).to.be.a("${2:string}")
snippet expto be instanceof
	expect(${1:expression}).to.be.instanceof("${2:string}")
snippet expto be true
	expect(${1:expression}).to.be.true
snippet expto be false
	expect(${1:expression}).to.be.false
snippet expto be null
	expect(${1:expression}).to.be.null
snippet expto be defined
	expect(${1:expression}).to.be.defined
snippet expto be undefined
	expect(${1:expression}).to.be.undefined
snippet expto be empty
	expect(${1:expression}).to.be.empty
snippet expto be above
	expect(${1:expression}).to.be.above(${2})
snippet expto be below
	expect(${1:expression}).to.be.below(${2})
snippet expto be within
	expect(${1:expression}).to.be.within(${2})
snippet expto exist
	expect(${1:expression}).to.exist
snippet expto include
	expect(${1:expression}).to.include(${2})
snippet expto contain
	expect(${1:expression}).to.contain(${2})
snippet expto match
alias em
	expect(${1:expression}).to.match(/${2}/)
snippet expto throw
	expect(${1:expression}).to.throw(${2})
snippet expto satisfy
	expect(${1:expression}).to.satisfy (${2:args}) ->
		${3}
# jasmine
snippet exp toBe
	expect(${1:expression}).toBe(${2:true})
snippet exp toNotBe
	expect(${1:expression}).toNotBe(${2:true})
snippet exp toEqual
	expect(${1:expression}).toEqual(${2:value})
snippet exp toNotEqual
	expect(${1:expression}).toNotEqual(${2:value})
snippet exp toMatch
	expect(${1:expression}).toMatch(${2:regex})
snippet exp toNotMatch
	expect(${1:expression}).toNotMatch(${2:regex})
snippet exp toBeDefined
	expect(${1:expression}).toBeDefined()
snippet exp toBeUndefined
	expect(${1:expression}).toBeUndefined()
snippet exp toBeNull
	expect(${1:expression}).toBeNull()
snippet exp toBeTruthy
	expect(${1:expression}).toBeTruthy()
snippet exp toBeFalsy
	expect(${1:expression}).toBeFalsy()
snippet exp toContain
	expect(${1:expression}).toContain(${2:string})
snippet exp toNotContain
	expect(${1:expression}).toNotContain(${2:string})
snippet exp toBeLessThan
	expect(${1:expression}).toBeLessThan(${2:number})
snippet exp toBeGreaterThan
	expect(${1:expression}).toBeGreaterThan(${2:number})
snippet exp toBeNaN
	expect(${1:expression}).toBeNaN()
snippet exp toBeCloseTo
	expect(${1:expression}).toBeCloseTo(${2:precision})
snippet exp toThrow
	expect(${1:expression}).toThrow()
# angular
snippet angular
alias ng
	angular.
snippet angular module
alias ngm
	angular.module("${1:moduleName}", [${2:dependency}])${0}
snippet angular module get
alias ngmm
	angular.module("${1:moduleName}")${0}
# angular scope
snippet scope
alias sco
	$scope
snippet scope fun
alias scf
options head
	$scope.${1:functionName} = (${2:args}) ->
		${3}
snippet scope var
alias scv
options head
	$scope.${1:variable} = ${2:value}
snippet scope watch
options head
	$scope.$watch "${1:watchExpr}", (newVal, oldVal) ->
		${2}
snippet scope on
options head
	$scope.$on "${1:eventName}", (event, ${2:args}) ->
		${3}
snippet scope broadcast
	$scope.$broadcast "${1:eventName}", ${2:eventArgs}
snippet scope emit
	$scope.$emit "${1:eventName}", ${2:eventArgs}
# angular core
snippet config angular
options word
	.config(function(${1:$routeProvider}) {
		${2}
	});
snippet config injectables angular
alias ngc
options word
	.config([
		"$routeProvider"
		($routeProvider) ->
			${1}
	])
snippet controller angular
options word
	.controller "${1:What}Controller", ($scope${2}) ->
		${3}
snippet controller injectables angular
alias ngctrl
options word
	.controller "${1:What}Controller", [
		"$scope",
		($scope) ->
			${2}
	]
snippet directive angular
options word
	.directive "${1:directiveName}", ->
		restrict: "${2:AE}"
		scope:
			${4}
		templateUrl: "${3:url}"
snippet directive injectables angular
alias ngdir
options word
	.directive "${1:directiveName}", [
		"${2:dependency}"
		($2) ->
			restrict: "${3:AE}"
			scope:
				${5}
			templateUrl: "${4:url}"
	]
snippet directive link angular
	link: (scope, element, attrs, ${1:ctrls}) ->
		${2}
snippet directive controller angular
	controllerAs: "${1}",
	controller: ($scope, $element, $attrs) ->
		${2}
snippet factory angular
options word
	.factory "${1:some}Factory", ->
		${2}
snippet factory injectables angular
alias ngfa
options word
	.factory "${1:some}Factory", [
		"${2:dependency}"
		($2) ->
			${3}
	]
snippet service angular
options word
	.service "${1:some}Service", ->
		${2}
snippet service injectables angular
alias ngse
options word
	.service "${1:some}Service", [
		"${2:dependency}"
		($2) ->
			${3}
	]
snippet filter angular
options word
	.filter "${1:filterName}", ->
		(input, ${2:args}) ->
			${3}
snippet filter injectables angular
alias ngfi
options word
	.filter "${1:filterName}", [
		"${2:dependency}"
		(${2}) ->
			(input) ->
				${3}
	]
# angular route
snippet route angular
alias ngr
	$routeProvider
	.when "${1:url}",
		templateUrl: "${2:templateUrl}"
		controller: "${3:controller}"
snippet when route angular
alias ngrw
	.when "${1:url}",
		templateUrl: "${2:templateUrl}"
		controller: "${3:controller}"
snippet when route resolve angular
alias ngrwr
	.when "${1:url}",
		templateUrl: "${2:templateUrl}"
		controller: "${3:controller}"
		resolve:
			${4}
snippet otherwise route angular
alias ngro
	.otherwise redirectTo: '${1:url}'
