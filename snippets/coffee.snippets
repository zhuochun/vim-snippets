# Closure loop
snippet for basic with do
	for ${1:name} in ${2:array}
		do ($1) ->
			${3:// body}
# For loop
snippet for basic
	for ${1:name} in ${2:array}
# Array comprehension
snippet for object
	for ${1:key}, ${2:value} in ${3:objects}
snippet for array comprehension
	for ${1:name} in ${2:array}
		${3:# body...}
# Object comprehension
snippet for object comprehension
	for ${1:key}, ${2:value} of ${3:object}
		${4:# body...}
# Range comprehension (inclusive)
snippet for range comprehension (inclusive)
	for ${1:name} in [${2:start}..${3:finish}]
		${4:# body...}
snippet for range comprehension (by inclusive)
	for ${1:name} in [${2:start}..${3:finish}] by ${4:step}
		${5:# body...}
# Range comprehension (exclusive)
snippet for range comprehension (exclusive)
	for ${1:name} in [${2:start}...${3:finish}]
		${4:# body...}
snippet for range comprehension (by exclusive)
	for ${1:name} in [${2:start}...${3:finish}] by ${4:step}
		${5:# body...}
# object
snippet obj
	${1:object} =
		${2:key}: ${3:value}
snippet :
	${2:key}: ${3:value}
# Function
snippet ->
	(${1:args}) ->
		${2:# body...}
snippet fun with params
	(${1:args}) ->
		${2:# body...}
snippet fun without params
	->
	${2:# body...}
# Function (bound)
snippet =>
	(${1:args}) =>
		${2:# body...}
snippet fun bound with params
	(${1:args}) =>
		${2:# body...}
snippet fun bound without params
	(${1:args}) =>
		${2:# body...}
# Class
snippet class class ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
snippet class class .. constructor: ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		constructor: (${2:@args}) ->
			${3}

		${4}
snippet class class .. extends ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		${3}
snippet class class .. extends .. constructor: ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		constructor: (${3:@args}) ->
			${4}

		${5}
snippet constructor
	constructor: (${1:@args}) ->
		${2}
snippet prototype
	${1:class}::${2:method} = ${3}
snippet ::
	${1:class}::${2:method} = ${3}
# If
snippet if
	if ${1:condition}
		${2:# body...}
snippet else
	else ${1:condition}
		${2:# body...}
# If __ Else
snippet ife
	if ${1:condition}
		${2:# body...}
	else
		${3:# body...}
# Else if
snippet elseif
	else if ${1:condition}
		${2:# body...}
# Ternary If
snippet ifthen
	if ${1:condition} then ${2:value} else ${3:other}
snippet ?
	if ${1:condition} then ${2:value} else ${3:other}
# Unless
snippet unless
	${1:action} unless ${2:condition}
# Switch
snippet swi
	switch ${1:object}
		when ${2:value}
			${3:# body...}
snippet when
	when ${2:value}
		${3:# body...}
# Log
snippet log
	console.log ${1}
# Try __ Catch
snippet try
	try
		${1}
	catch ${2:error}
		${3}
# Require
snippet req
	${2:$1} = require '${1:sys}'${3}
# Export
snippet exp
	${1:root} = exports ? this
# Asset Pipeline
snippet rreq
	#= require ${1:file}
# BDD Testings
snippet describe
alias des
	describe "${1:context to test}", ->
		${2}
snippet it
	it "${1:should do something}", ->
		${2}
snippet it async
alias ita
	it "${1:should do something}", (done) ->
		${2:done()}
snippet before
	before ${1:(done) }->
		${2}
snippet after
	after ${1:(done) }->
		${2}
snippet beforeEach
	beforeEach ${1:(done) }->
		${2}
snippet afterEach
	afterEach ${1:(done) }->
		${2}
# Chai - Assert
snippet chai require assert
alias cha
	assert = require("chai").assert${1:,}
snippet assert
alias as
	assert(${1:expression}, '${2:message}')
snippet assert equal
alias ae
	assert.equal(${1:actual}, ${2:expected}, '${3:message}')
snippet assert not equal
alias ane
	assert.notEqual(${1:actual}, ${2:expected}, '${3:message}')
snippet assert strict equal
alias ase
	assert.strictEqual(${1:actual}, ${2:expected}, '${3:message}')
snippet assert not strict equal
alias anse
	assert.notStrictEqual(${1:actual}, ${2:expected}, '${3:message}')
snippet assert deep equal
alias ade
	assert.deepEqual(${1:actual}, ${2:expected}, '${3:message}')
snippet assert not deep equal
alias ande
	assert.notDeepEqual(${1:actual}, ${2:expected}, '${3:message}')
snippet assert isTrue
alias at
	assert.isTrue(${1:value}, '${2:message}')
snippet assert isFalse
alias af
	assert.isFalse(${1:value}, '${2:message}')
snippet assert isNull
	assert.isNull(${1:value}, '${2:message}')
snippet assert isUndefined
	assert.isUndefined(${1:value}, '${2:message}')
snippet assert isDefined
	assert.isDefined(${1:value}, '${2:message}')
snippet assert isFunction
	assert.isFunction(${1:value}, '${2:message}')
snippet assert isObject
	assert.isObject(${1:value}, '${2:message}')
snippet assert isArray
	assert.isArray(${1:value}, '${2:message}')
snippet assert isString
	assert.isString(${1:value}, '${2:message}')
snippet assert isNumber
	assert.isNumber(${1:value}, '${2:message}')
snippet assert typeOf
	assert.typeOf(${1:value}, ${2:name}, '${3:message}')
snippet assert match
	assert.match(${1:value}, ${2:regex}, '${3:message}')
snippet assert lengthOf
	assert.lengthOf(${1:object}, ${2:length}, '${3:message}')
# Chai - Expect
snippet chai require expect
alias che
	expect = require("chai").expect${1:,}
snippet expect general
alias ex
	expect(${1:expression}).to.${2:equal}(${3})
snippet expect equal
alias ee
	expect(${1:expression}).to.equal(${2})
snippet expect not equal
alias ene
	expect(${1:expression}).to.not.equal(${2})
snippet expect deep equal
alias ede
	expect(${1:expression}).to.deep.equal(${2})
snippet expect eql
alias eeql
	expect(${1:expression}).to.eql(${2})
snippet expect be a
	expect(${1:expression}).to.be.a("${2:string}")
snippet expect be instanceof
	expect(${1:expression}).to.be.instanceof("${2:string}")
snippet expect be true
alias ebt
	expect(${1:expression}).to.be.true
snippet expect be false
alias ebf
	expect(${1:expression}).to.be.false
snippet expect be null
	expect(${1:expression}).to.be.null
snippet expect be defined
	expect(${1:expression}).to.be.defined
snippet expect be undefined
	expect(${1:expression}).to.be.undefined
snippet expect be empty
	expect(${1:expression}).to.be.empty
snippet expect be above
	expect(${1:expression}).to.be.above(${2})
snippet expect be below
	expect(${1:expression}).to.be.below(${2})
snippet expect be within
	expect(${1:expression}).to.be.within(${2})
snippet expect exist
	expect(${1:expression}).to.exist
snippet expect include
	expect(${1:expression}).to.include(${2})
snippet expect contain
	expect(${1:expression}).to.contain(${2})
snippet expect match
alias em
	expect(${1:expression}).to.match(/${2}/)
snippet expect throw
	expect(${1:expression}).to.throw(${2})
snippet expect satisfy
	expect(${1:expression}).to.satisfy (${2:args}) ->
		${3}
