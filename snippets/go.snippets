# package
snippet package
alias pack
	package ${1:`substitute(vim_snippets#Filename(), '\(_test\)', '', 'g')`}

# import
snippet import
	import "${0:fmt}"
# import ()
snippet imp
	import (
		"${1:fmt}"
		${0}
	)
# import ("testing")
snippet imp testing
	import (
		"${1:testing}"
		${0}
	)

# main()
snippet main
	package main

	import (
		"${1:package}"
	)

	func main() {
		${0}
	}

# function simple
snippet func
alias fn
	func ${1:funcName}(${2:arg type}) ${3:return type} {
		${0}
	}
# function with error
snippet func err
alias fe
	func ${1:funcName}(${2:arg type}) ${3:error} {
		${0}
	}
# function with return result
snippet func return
alias fr
	func ${1:funcName}(${2:arg type}) (${3:return type}, ${4:err error}) {
		${0}
	}
# function on receiver
snippet func self
alias fm
	func (${1:self} ${2:type}) ${3:funcName}(${4:arg type}) ${5:error} {
		${0}
	}
# function new
snippet func new
alias fnew
	func New${1:Instance}(${2:arg type}) *${1} {
		${0}

		return &$1
	}
# function definition in interface
snippet func interface
alias fni
	${1:Method}(${2:arg type}) (${3:return_type})
snippet args
	${1:args} ...interface{}

# function that returns a channel
snippet func generator
	func ${1:funcName}(${2:arg type}) <-chan ${3:type} {
		${4:c} := make(chan $3)

		go func() {
			${0}
		}()

		return $4
	}

# if condition
snippet if
	if ${1:condition} {
		${2}
	}
# if else
snippet ifel
	if ${1:condition} {
		${2}
	} else {
		${3}
	}
# else snippet
snippet elseif
	else if ${1:condition} {
		${0}
	}
# if nil
snippet ifn
	if ${1:err} != nil {
		${0:return}
	}
# if error snippet
snippet ifer
	if err != nil {
		return${0: err}
	}
snippet ifer return
	if err := ${1}; err != nil {
		return${0: err}
	}

# select
snippet select
alias sel
	select {
	case ${1:v} := <-${2:chan1}:
		${3}
	default:
		${0}
	}
# switch
snippet switch
alias sw
	switch ${1:var} {
	case ${2:value1}:
		${3}
	default:
		${0}
	}
# case
snippet case
	case ${1:value}:
		${0}
snippet case chan
	case ${1:v} := <- ${2:chan1}:
		${0}
snippet default
	default:
		${0}

# for loop
snippet for
	for ${1:condition} {
		${0}
	}
snippet while
alias loop
	for {
		${0}
	}
snippet fori
	for ${1:i} := 0; $1 < ${2:count}; $1${3:++} {
		${0}
	}
# for range loop
snippet forr
	for ${1:k}, ${2:v} := range ${3:collections} {
		${0}
	}
snippet forr value
	for ${1:v} := range ${2:collections} {
		${0}
	}

# interface
snippet interface
alias any
	interface{}
# full interface snippet
snippet interface name
	interface ${1:name} {
		${0:methods}
	}

# struct
snippet struct
	struct ${1:name} {
		${2:data}
	}

# type struct
snippet type
	type ${1:typeName} ${2:type}
snippet type struct
alias typs
	type ${1:typeName} struct {
		${0:data}
	}
# type interface
snippet type interface
alias typi
	type ${1:typeName} interface {
		${0:methods}
	}

# json
snippet json
	${1:Name} ${2:type} \`json:"${3:key}"\`
snippet json Marshal
	${1:data}, err := json.Marshal(${2:v})
snippet json Unmarshal
	err := json.Unmarshal(${1:data}, &${2:v})
snippet json encode
	json.NewEncoder(${1:io.Writer}).Encode(${2:data})
snippet json decode
	json.NewDecoder(${1:io.Reader}).Decode(&${2:v})

# const
snippet c
	const ${1:NAME} = ${2:0}
# constants with iota
snippet const
	const (
		${1:NAME1} = iota
		${2:NAME2}
	)

# variables
snippet -
	${1:chan} <- ${2:data}
snippet &
	&${1:Struct}{${2:args}}
snippet -c
	<-chan ${1:int}
snippet c-
	chan<- ${1:int}
snippet v
	${1:name} := ${2:value}
snippet ve
	${1:name}, ${2:err} := ${3:action}
	if $2 != nil {
		${0:return}
	}
snippet ok
	${1:val}, ok := ${2:<-ch}
	if ok {
		${0}
	}
snippet va
	var ${1:name} ${2:int} = ${3:value}
snippet vcr
	var ${1:chan_name} chan<- ${2:int}
snippet vcw
	var ${1:chan_name} <-chan ${2:int}
snippet vs
	var ${1:name} struct {
		${0}
	}

# defer
snippet defer
alias def
	defer ${1:func}()
# def func
snippet defer func
alias deff
	defer func() {
		${0}
	}()
# defer recover
snippet defer recover
alias defr
	defer func() {
		if err := recover(); err != nil {
			${0}
		}
	}()

# go
snippet go
	go ${1:funcName}(${2})
# goroutine anonymous function
snippet go func
alias ga
	go func(${1:arg type}) {
		${0:/* code */}
	}(${2:arg})

# string
snippet st
	string
# bool
snippet bl
	bool
# byte
snippet bt
	byte
# float
snippet fl
	float32
# float32
snippet f3
	float32
# float64
snippet f6
	float64
# channel
snippet ch
	chan ${1:int}

# continue
snippet con
	continue
# fallthrough
snippet fal
	fallthrough
# result
snippet res
	result
# return
snippet ret
	return ${1}, ${2:nil}
# range
snippet ran
	range ${1}
# len
snippet len
	len(${1:var})
# make
snippet make
alias ma
	make(${1:[]string}, ${2:0})
snippet make chan
alias mac
	make(chan ${1:int}, ${2:1})
# close
snippet close
alias cl
	close(${1:ch})
# append
snippet app
	append(${1:slice}, ${2:value})
# map
snippet map
	map[${1:string}]${2:int}
# new
snippet new
	new(${1:type})
# panic
snippet panic
alias pan
	panic("${1:msg}")

# runtime package

# sync package
snippet sync
	var ${1:mutex} sync.${2:Mutex}
snippet mutex.Lock
	mutex.Lock()
	defer mutex.Unlock()

	${0}

# log package
snippet log.Printf
alias lf
	log.Printf("%${1:s}", ${2:var})
snippet log.Println
alias ll
	log.Println("${1}")

# fmt package
snippet fmt.Println
alias pl
	fmt.Println(${1})
snippet fmt.Printf
alias pf
	fmt.Printf("${1}", ${2:var})
snippet fmt.Sprintf
alias sp
	fmt.Sprintf("${1}", ${2:var})

# testing package
snippet func test
	func Test${1:FuncName}(t *testing.T) {
		${0}
	}
snippet t.Error
	t.Error("${1:test failed}", ${2:actual}, ${3:expected})

# flag package
snippet flag
	var ${1:name} *${2:type} = flag.${3:Type}("${4:short}", "${5:default}", "${6:description}")
snippet flag.Parse
	flag.Parse()

# snippets
snippet timeout
	timeout = time.After(${1:1} * time.Millisecond)

	for ${2} {
		select {
		case ${3:v} := <-${4:chan1}:
			${0}
		case <-timeout
			return
		}
	}
