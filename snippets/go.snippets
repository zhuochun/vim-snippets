# import
snippet i
	import "${0:package}"
# import ()
snippet import
	import (
		"${0:package}"
	)

# main()
snippet main
	package main

	import (
		"${1:package}"
	)

	func main() {
		${0}
	}

# function simple
snippet func
	func ${1:funcName}(${2:arg type}) ${3:error} {
		${0}
	}
# function with return result
snippet func err
	func ${1:funcName}(${2:arg type}) (${3:return_type}, ${4:error}) {
		${0}
	}
# function on receiver
snippet func self
	func (${2:self} ${1:type}) ${3:funcName}(${4:arg type}) ${5:error} {
		${0}
	}
# function definition in interface
snippet func interface
	${1:Method}(${2:arg type}) (${3:return_type})

# if condition
snippet if
	if ${1:condition} {
		${2}
	}
# if else
snippet ie
	if ${1:condition} {
		${2}
	} else {
		${3}
	}
# else snippet
snippet el
	else if ${1:condition} {
		${0}
	}
# if error snippet
snippet ifer
	if err != nil {
		return ${0:err}
	}
snippet ife
	if err := ${1}; err != nil {
		return ${0:err}
	}

# select
snippet select
	select {
	case ${1:v1} := <-${2:chan1}:
		${3}
	default:
		${0}
	}
# switch
snippet switch
	switch ${1:var} {
	case ${2:value1}:
		${3}
	default:
		${0}
	}
# case
snippet case
	case ${1:value}:
		${0}

# for loop
snippet for
	for ${1:condition} {
		${0}
	}
snippet fori
	for ${1:i} := 0; $1 < ${2:count}; $1${3:++} {
		${0}
	}
# for range loop
snippet forr
	for ${1:k}, ${2:v} := range ${3} {
		${0}
	}

# interface
snippet int empty
	interface{}
# full interface snippet
snippet int
	interface ${1:name} {
		${0:methods}
	}

# struct
snippet struct
	struct ${1:name} {
		${2:data}
	}

# type struct
snippet type struct
	type ${1:typeName} struct {
		${0:data}
	}
# type interface
snippet type interface
	type ${1:typeName} interface {
		${0:methods}
	}

# json
snippet json
	${1:Name} ${2:type} \`json:"${3:key}"\`
snippet json Marshal
	${1:data}, err := json.Marshal(${2:v})
snippet json Unmarshal
	err := json.Unmarshal(${1:data}, &${2:v})
snippet json encode
	json.NewEncoder(${1:io.Writer}).Encode(${2:data})
snippet json decode
	json.NewDecoder(${1:io.Reader}).Decode(&${2:v})

# const
snippet c
	const ${1:NAME} = ${2:0}
# constants with iota
snippet const
	const (
		${1:NAME1} = iota
		${2:NAME2}
	)

# variables
snippet v
	${1} := ${2}
snippet var
	var ${1} ${2} = ${3}
snippet var struct
	var ${1} struct {
		${0}
	}

# defer
snippet defer
	defer ${1:func}()
# defer recover
snippet defer recover
	defer func() {
		if err := recover(); err != nil {
			${0}
		}
	}()

# go
snippet go
	go ${1:funcName}(${2})
# goroutine anonymous function
snippet ga
	go func(${1} ${2:type}) {
		${0:/* code */}
	}(${3:arg})

# log Printf
snippet log.Printf
	log.Printf("%${1:s}", ${2:var})
# log Println
snippet log.Println
	log.Println("${1}")

# fmt Printf
snippet fmt.Printf
	fmt.Printf("%${1:s}\n", ${2:var})
snippet fmt.Println
	fmt.Println(${1})
# fmt Sprintf
snippet fmt.Sprintf
	fmt.Sprintf("%${1:s}", ${2:var})

# string
snippet st
	string
# bool
snippet bl
	bool
# byte
snippet bt
	byte
# float
snippet fl
	float32
# float32
snippet f3
	float32
# float64
snippet f6
	float64
# channel
snippet ch
	chan ${1:int}

# continue
snippet cn
	continue
# fallthrough
snippet ft
	fallthrough
# result
snippet rs
	result
# return
snippet rt
	return ${1}, ${2:nil}
# range
snippet rn
	range ${1}

# make
snippet mk
	make(${1:[]string}, ${2:0})
# append
snippet ap
	append(${1:slice}, ${2:value})
# map
snippet mp
	map[${1:string}]${2:int}
# new
snippet nw
	new(${1:type})
# panic
snippet pn
	panic("${1:msg}")
