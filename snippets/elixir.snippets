snippet .
options word
	.(${0})
snippet &
	&(${0})
snippet ..
options indent
	|> ${0}
snippet <<
	<< ${0} >>
snippet ->
	${1:condition} ->
		${0}
snippet %
	%${1:Struct}{${0:fields}}
snippet %|
	%{${1:map} | ${0:k: v}}
snippet tuple
	{${0:tuple}}
snippet keyword
	[${1:k1}: ${2:v2}, ${3:k1}: ${4:v2}]

# sigils
snippet ~r
alias //
	~r/${0:regexp}/
snippet ~R
	~R/${0:no interpolation regexp}/
snippet ~s
	~s(${0:string})
snippet ~S
	~S(${0:no interpolation string})
snippet ~w
	~w(${0:words})
snippet ~W
	~W(${0:no interpolation words})
snippet ~i
	~w(${0:words})a
snippet ~I
	~W(${0:no interpolation words})a
snippet ~c
	~c(${0:chars})
snippet ~C
	~C(${0:no interpolation chars})

snippet ,d
	, do: ${0}
snippet do
	do
		${0}
	end
snippet try rescue
	try do
		${1}
	rescue
		${2} -> ${0}
	end
snippet raise
	raise ${1:RuntimeError}, message: "${0:content}"
snippet if
	if ${1} do
		${0}
	end
snippet ife
	if ${1:condition} do
		${2}
	else
		${0}
	end
snippet ifd
	if ${1:condition}, do: ${0}
snippet ifde
	if ${1:condition}, do: ${2}, else: ${0}
snippet unless
	unless ${1} do
		${0}
	end
snippet unlessd
	unless ${1:condition}, do: ${0}
snippet cond
	cond do
		${1:bool} ->
			${0}
		true ->
			${2}
	end
snippet case
	case ${1} do
		${2:match [guard]} ->
			${0}
		_ ->
			${3}
	end
snippet case ok
	case ${1} do
		{:ok, ${2:data}} ->
			${3}
		{:error, ${4:message}} ->
			${0}
	end
snippet for
	for ${1:item} <- ${2:items} do
		${0}
	end
snippet fori
	for ${1:item} <- ${2:items}, into: ${3} do
		${0}
	end

snippet req
	require ${0:moduleName}
snippet imp
	import ${0:moduleName}
snippet imp only
	import ${1:moduleName}, only: [${2:method}: ${0:1}]
snippet imp except
	import ${1:moduleName}, except: [${2:method}: ${0:1}]
snippet ali
	alias ${0:moduleName}
snippet ali as
	alias ${1:moduleName}, as: ${0:name}

snippet when
	when ${0:val > 0}
snippet fn
	fn ${1:args} -> ${0} end
snippet def
	def ${1:name}(${2}) do
		${0}
	end
snippet defd
	def ${1:name}(${2}), do: ${0}
snippet defp
	defp ${1:name}(${2}) do
		${0}
	end
snippet defpd
	defp ${1:name}(${2}), do: ${0}
snippet defma
	defmacro ${1:name}(${2}) do
		${0:params are quoted args, return quoted code}
	end
snippet quote
	quote do
		${0:return internal rep}
	end
snippet quote bind_quoted
	quote bind_quoted: [${1:arg}: ${2:val}] do
		${0}
	end
snippet unquote
	unquote do
		${0}
	end
snippet defm
	defmodule ${1:#:Module.}${2:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		${0}
	end
snippet defs
	defmodule ${1:#:Module.}${2:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		defstruct ${3:field}: ${0:default}
	end
snippet defpr
	defprotocol ${1:name} do
		${0}
	end
snippet defi
	defimpl ${1:protocol_name}, for: ${2:data_type} do
		${0}
	end

# Tags
snippet @doc
	@doc """
	${0}
	"""
snippet @docs
	@doc ~S"""
	${0}
	"""
snippet @mdoc
	@moduledoc """
	${0}
	"""
snippet @mdocs
	@moduledoc ~S"""
	${0}
	"""
snippet @tag
	@tag :${1:pending}

# Agent
# http://elixir-lang.org/docs/stable/elixir/Agent.html
snippet agent start_link
	Agent.start_link(fn -> ${0:MapSet.new} end, name: ${1:__MODULE__})
snippet agent get
	Agent.get(${1:__MODULE__}, fn ${2:arg} -> ${0} end, ${3:timeout})
snippet agent get_and_update
	Agent.get_and_update(${1:__MODULE__}, fn ${2:arg} -> ${0} end, ${3:timeout})
snippet agent cast
	Agent.cast(${1:__MODULE__}, fn ${2:arg} -> ${0} end)

# ExUnit
# http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Assertions.html
snippet defm ExUnit
	defmodule ${1:#:Module.}${2:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		use ExUnit.Case

		${0}
	end
snippet test
	test "${1:test_name}" do
		${0}
	end
snippet testa
	test "${1:test_name}", %{${2:arg: val}} do
		${0}
	end
snippet assert
alias ass
	assert ${0:assertion}
snippet assert_raise
alias assra
	assert_raise ${1:exception}, ${0:function}
snippet assert_receive
alias assre
	assert_receive ${1:expected}, ${2:timeout \\ 100}
snippet refute
alias ref
	refute ${0:assertion}
snippet imp ExUnit.CaptureIO
	import ExUnit.CaptureIO
snippet cature_io
	capture_io fn ->
		${0}
	end
snippet imp ExUnit.CaptureLog
	import ExUnit.CaptureLog
snippet cature_log
	capture_log fn ->
		${0}
	end

# ExUnit > DocTest
# http://elixir-lang.org/docs/stable/ex_unit/ExUnit.DocTest.html
snippet iex
	iex> ${0:code snippet}
snippet iex .
	...> ${0:code snippet}

snippet pry
	require IEx; IEx.pry${0}
snippet p
	IO.puts ${0}
snippet i
	IO.inspect ${0}
snippet sys halt
	System.halt(${0:0})
snippet app get_env
	Application.get_env(:${1:project}, :${2:key})
snippet config
	config :${1:project}, ${2:key}: ${3::value}

# Processes
snippet spawn
alias spa
	spawn(${1:__MODULE__}, :${2:func}, [${3:args}])
snippet spawn anonymous_func
	spawn(${1:anonymous_func})
snippet send
	send(${1:pid}, {${0:data}})
snippet receive
alias rec
	receive do
		${1} -> ${0}
	end
snippet receive timeout
	receive do
		{sender, ${1}} ->
			${0}
			send sender {:ok, value}
		after timeout ->
			${2}
	end

# Predefined names
snippet _MO
	__MODULE__
snippet _FI
	__FILE__
snippet _DI
	__DIR__
snippet _EN
	__ENV__
snippet _CA
	__CALLER__

# Operators
snippet is_atom
	is_atom(${0})
snippet is_binary
	is_binary(${0})
snippet is_bitstring
	is_bitstring(${0})
snippet is_boolean
	is_boolean(${0})
snippet is_exception
	is_exception(${0})
snippet is_float
	is_float(${0})
snippet is_function
	is_function(${0})
snippet is_integer
	is_integer(${0})
snippet is_nil
	is_nil(${0})
snippet is_list
	is_list(${0})
snippet is_number
	is_number(${0})
snippet is_pid
	is_pid(${0})
snippet is_port
	is_port(${0})
snippet is_reference
	is_reference(${0})
snippet is_tuple
	is_tuple(${0})

# Logger
# http://elixir-lang.org/docs/stable/logger/Logger.html
snippet log
	Logger.${1:info} ${0:"message"}
snippet log fn
	Logger.${1:info} fn -> ${0:"message"} end
snippet log metadata
	Logger.metadata(${0:dict})

# Enum
snippet enum ma
	Enum.map ${1}, ${0:fun}
snippet enum take
	Enum.take ${0:3}
snippet enum into
	Enum.into ${1}, ${0:[]}
snippet enum tolist
	Enum.to_list ${0}

# Stream
snippet stream map
	Stream.map ${1:enumerable}, ${0:fun}
snippet stream filter
	Stream.filter ${1:enumerable}, ${0:fun}
snippet stream cycle
	Stream.cycle(~w{ ${0:words} })
snippet stream repeatedly
	Stream.repeatedly(${0:fun})
snippet stream iterate
	Stream.interate(${1:start_value}, ${0:next_fun})
snippet stream unfold
	Stream.unfold(${1:start_value}, fn ${2:val} -> {${3:result}, ${4:next_val}} end)
snippet stream resource
	Stream.resource(${1:resource_fun}, ${2:next_fun}, ${3:close_fun})

# String

# IO
snippet io stream
	IO.stream(:line)

# Erlang global
snippet :global register_name
	:global.register_name(${1::uniq_name}, ${2:pid})
snippet :global whereis_name
	:global.whereis_name(${1::uniq_name})

# Erlang time
snippet :time tc
	:timer.tc(${1:Module}, ${2:method}, [${3:args}])
